







{{#FrequenciesStylized}}
  {{FrequenciesStylized}}
{{/FrequenciesStylized}}


<script>

var logger = (function (my) {
  let uniqueKeys = new Set();

  let _appendMsg = function(message, groupEle, key=null) {
    // I think this stops an infinite loop somewhere if you log a null for some reason...
    if (message === null) {
      message = "null";
    }

    let msgEle = document.createElement('div');
    msgEle.classList.add("info-circle__message")
    if (key !== null) {
      msgEle.setAttribute("data-key", key);
    }

    if (Array.isArray(message)) {
      if (message.length > 0) {
        msgEle.textContent = message[0];

        for (let line of message.slice(1)) {
          let lineEle = document.createElement('div');
          lineEle.textContent = line;
          msgEle.appendChild(lineEle);
        }
      }

    } else {
      msgEle.textContent = message;
    }
    groupEle.appendChild(msgEle);
  }

  my.error = function(message) {
    let groupEle = document.getElementById("info_circle_text_error");
    _appendMsg(message, groupEle);
    let infoCirc = document.getElementById("info_circle");
    if (!infoCirc.classList.contains("info-circle-error")) {
      infoCirc.classList.add("info-circle-error")
    }
  }

  my.assert = function(condition, message) {
    if (!condition) {
      my.error("(assert) " + message);
    }
  }

  my.removeWarn = function(key) {
    // assumes that this is a unique warn message

    if (!uniqueKeys.has(key)) {
      return;
    }

    let groupEle = document.getElementById("info_circle_text_warning");
    for (let e of groupEle.children) {
      if (e.getAttribute("data-key") === key) {
        groupEle.removeChild(e);
      }
    }

    let infoCirc = document.getElementById("info_circle");
    if (groupEle.children.length === 0 && infoCirc.classList.contains("info-circle-warning")) {
      infoCirc.classList.remove("info-circle-warning")
    }

    uniqueKeys.delete(key);
  }

  // key defaults to the message if unique is true and key is null
  // key is ignored if unique == false
  my.warn = function(message, unique=true, key=null) {

    // skips any non-unique warns as defined by the key
    if (unique) {
      if (key === null) {
        key = message;
      }

      if (uniqueKeys.has(key)) {
        return;
      }
    }

    let groupEle = document.getElementById("info_circle_text_warning");
    _appendMsg(message, groupEle, key);
    let infoCirc = document.getElementById("info_circle");
    if (!infoCirc.classList.contains("info-circle-warning")) {
      infoCirc.classList.add("info-circle-warning")
    }

    if (key !== null) {
      uniqueKeys.add(key);
    }

  }

  my.info = function(message) {
    let groupEle = document.getElementById("info_circle_text_info");
    _appendMsg(message, groupEle);
  }


  my.leech = function() {
    let groupEle = document.getElementById("info_circle_text_leech");
    _appendMsg("", groupEle);
    let infoCirc = document.getElementById("info_circle");
    if (!infoCirc.classList.contains("info-circle-leech")) {
      infoCirc.classList.add("info-circle-leech")
    }
  }

  return my;
}(logger || {}));



// on any javascript error: log it
window.onerror = function(msg, url, lineNo, columnNo, error) {
//window.onerror = function(msg) {
  //logger.error("Javascript error: `" + msg + "`" + "\n" + error.stack);
  let stackList = error.stack.split(" at ");
  for (let i = 1; i < stackList.length; i++) {
    stackList[i] = ">>> " + stackList[i];
  }
  logger.error(stackList);
}

// https://stackoverflow.com/a/55178672
window.onunhandledrejection = function(errorEvent) {
  logger.error("Javascript handler error: `" + errorEvent.reason + "`");
}


function optionsNotFound() {
  logger.warn("Options file not found. Did you place the options file in the media directory?");
}



</script>

<script onerror="optionsNotFound();" src="_jpmn-options.js"></script>


<div class="card-description">
  

    

    

  PA Word



    
  <span class="info-circle" id="info_circle">
    <span class="info-circle-svg-wrapper">
      <svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" class="bi bi-info-circle" viewBox="0 0 16 16">
        <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
        <path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
      </svg>
    </span>

    <span class="info-circle-text-wrapper">
      <span class="info-circle-text" id="info_circle_text">
        <div class="info-circle-text-error" id="info_circle_text_error"></div>
        <div class="info-circle-text-warning" id="info_circle_text_warning"></div>
        <div class="info-circle-text-leech" id="info_circle_text_leech"></div>
        <div class="info-circle-text-info" id="info_circle_text_info">
          <div>
            Need help? View the
            <a href="https://github.com/Aquafina-water-bottle/jp-mining-note/wiki">documentation</a>.
          </div>
          <div>
            Have an issue?
            <a href="https://github.com/Aquafina-water-bottle/jp-mining-note/issues">Report it here</a>.
          </div>
          <div>
            View the
            <a href="https://github.com/Aquafina-water-bottle/jp-mining-note">source code</a>.
          </div>
        </div>
      </span>
    </span>
  </span>


    
  <div class="card-description-ver">JP Mining Note: Version 0.9.1.0</div>


    
</div>







<!-- note that for the PA separate word card, the front is ALWAYS a word -->
<!-- priority: AltDisplay -> Word -->

<!-- option 1: AltDisplay (only if the original card is not a sentence card or hybrid card) -->
<div class="outer-display1
    {{^IsClickCard}}{{^IsHoverCard}}{{^IsSentenceCard}}{{^IsTargetedSentenceCard}}
    {{#AltDisplay}}
      outer-display2
    {{/AltDisplay}}
    {{/IsTargetedSentenceCard}}{{/IsSentenceCard}}{{/IsHoverCard}}{{/IsClickCard}}
    "
  id="Display">

  <!-- if NOT (altdisplay, AND none of (click, hover, sentence, TSC)) -->
  <div class="expression expression--single expression--word inner-display1">
    {{Word}}
  </div>

  <!-- if altdisplay, AND none of (click, hover, sentence, TSC) -->
  <div class="expression expression--single expression--word inner-display2">
    {{furigana:AltDisplay}}
  </div>
</div>



{{#HintNotHidden}}
  <div class="center-box-1 hint">
    <div class="center-box-2">
      <div class="bold-yellow">{{HintNotHidden}}</div>
    </div>
  </div>
{{/HintNotHidden}}

<!-- https://stackoverflow.com/questions/1269589/css-center-block-but-align-contents-to-the-left -->
<!-- tl;dr wrap anything you want centered + left justified with center-box-1 and center-box-2 -->
{{#Hint}}
  <details class="hint" id="hint_details">
    <summary>Hint</summary>
    <div class="center-box-1">
      <div class="center-box-2">
        <div class="bold-yellow">{{Hint}}</div>
      </div>
    </div>
  </details>
{{/Hint}}







<center>
  <div class="answer-border"></div>
</center>







<div class="def-header" id="def_header">

  <!-- everything on the left side -->
  
  <div class="dh-left dh-left--blue-border" id="dh_left">

    <div class="dh-left__reading" id="dh_reading"> {{furigana:WordReading}} </div>

    
    <div class="dh-left__word-pitch " id="dh_word_pitch">
      {{#WordPitch}}
        {{WordPitch}}
      {{/WordPitch}}
      {{^WordPitch}}
        (N/A)
      {{/WordPitch}}
    </div>

    <div class="dh-left__audio-buttons">
      <span id="word-audio"> {{WordAudio}} </span>
      <span id="sentence-audio"> {{SentenceAudio}} </span>
    </div>

  </div>

  <!-- everything on the right side -->
  {{#Picture}}
  <div class="dh-right" id="dh_right">
    <div class="dh-right__img-container" id="dh_img_container">{{Picture}}</div>
  </div>
  {{/Picture}}

</div>



<div id="back_side" class="back-side">


<div class="center-box-1">
  <div class="center-box-2">
    <div class="full-sentence bold-yellow" id="full_sentence">
      {{furigana:SentenceReading}}
    </div>
  </div>
</div>



<blockquote class="glossary-blockquote bold-yellow" id="primary_definition">
  <div class="glossary-text glossary-text--primary-definition">
    {{furigana:PrimaryDefinition}}
  </div>
</blockquote>


{{#SecondaryDefinition}}
  <details class="glossary-details" id="secondary_definition_details">
    <summary>Secondary Definition</summary>
    <blockquote class="glossary-blockquote bold-yellow">
      <div class="glossary-text glossary-text--secondary-definition">
        {{SecondaryDefinition}}
      </div>
    </blockquote>
  </details>
{{/SecondaryDefinition}}
{{^SecondaryDefinition}}
  <div class="glossary-details glossary-details--grey">
    Secondary Definition
  </div>
{{/SecondaryDefinition}}


{{#AdditionalNotes}}
  <details class="glossary-details glossary-details--small" id="additional_notes_details">
    <summary>Additional Notes</summary>
    <blockquote class="glossary-blockquote glossary-blockquote--small bold-yellow">
      <div class="glossary-text glossary-text--additional-notes">
        {{AdditionalNotes}}
      </div>
    </blockquote>
  </details>
{{/AdditionalNotes}}
{{^AdditionalNotes}}
  <div class="glossary-details glossary-details--small glossary-details--grey">
    Additional Notes
  </div>
{{/AdditionalNotes}}

{{#ExtraDefinitions}}
  <details class="glossary-details glossary-details--small" id="extra_definitions_details">
    <summary>Extra Definitions</summary>
    <blockquote class="glossary-blockquote glossary-blockquote--small bold-yellow">
      <div class="glossary-text glossary-text--extra-definitions">
        {{ExtraDefinitions}}
      </div>
    </blockquote>
  </details>
{{/ExtraDefinitions}}
{{^ExtraDefinitions}}
  <div class="glossary-details glossary-details--small glossary-details--grey">
    Extra Definitions
  </div>
{{/ExtraDefinitions}}



<div class="outer-display1
    {{^PAGraphs}}{{^UtilityDictionaries}}
      outer-display2
    {{/UtilityDictionaries}}{{/PAGraphs}}"
  id="Display">

  <!-- only showed if outer-display2 doesn't exist -->
  <details class="glossary-details glossary-details--small inner-display1" id="extra_info_details">
    <summary>Extra Info</summary>
    <blockquote class="glossary-blockquote glossary-blockquote--small bold-yellow">
      <div class="glossary-text glossary-text--extra-info">

        <div class="pa-graphs">
          {{PAGraphs}}
        </div>

        <div class="utility-dicts">
          {{UtilityDictionaries}}
        </div>

      </div>
    </blockquote>
  </details>

  <!-- only showed if outer-display2 exists -->
  <div class="glossary-details glossary-details--small glossary-details--grey inner-display2">
    Extra Info
  </div>

</div>






</div> <!-- backside -->


<!--
  https://codeconvey.com/html-image-zoom-on-click/
  http://www.liangshunet.com/en/202005/743233073.htm
  https://stackoverflow.com/questions/8449933/how-to-transition-css-display-opacity-properties
  https://www.javascripttutorial.net/dom/css/add-styles-to-an-element/
  https://stackoverflow.com/questions/507138/how-to-add-a-class-to-a-given-element
-->
<!-- The Modal -->
<div id="modal" class="modal">
  <img class="modal-img" id="bigimg">
</div>


<script>



/// /// 

// import settings as a global variable
// https://forums.ankiweb.net/t/how-to-include-external-files-in-your-template-js-css-etc-guide/11719

//function getAnkiPrefix() {
//  // TODO cross-platform support
//  // "https://appassets.androidplatform.net" ?
//  return "./";
//}
//
//var OPTIONS_FILE = "jp-mining-note-options.js"; // const screws up anki for some reason lol

// import statements cannot be contained in a function, if statement, etc.
//import {createOptions} from getAnkiPrefix() + OPTIONS_FILE;

//import {createOptions} from "./jp-mining-note-options.js";



// global cache for an entire card's kanji hover html
// maps key.word_reading -> html string
var kanjiHoverCardCache = kanjiHoverCardCache ?? {};

// maps kanji -> [{set of used words}, html string]
var kanjiHoverCache = kanjiHoverCache ?? {};

// note that this cache will NOT respect card review undos,
// but that should be a niche enough case to not warrent caching.
// maps key -> bool
var isNewCardCache = isNewCardCache ?? {};

(function () { // restricts ALL javascript to hidden scope

// "global" variables within the hidden scope
let note = (function () {
  let my = {};
  my.colorQuotes = false;
  return my;
}());



function getSetting(keys, defaultVal) {
  if (typeof JPMNOpts === "undefined") {
    return defaultVal;
  }

  let keyList = ["settings"].concat(keys);

  let obj = JPMNOpts;
  for (let key of keyList) {
    if (!(key in obj)) {

      // checks if we need to warn, manual search
      if ("settings" in JPMNOpts && "debug" in JPMNOpts["settings"] && JPMNOpts["settings"]["debug"]) {
        logger.warn("Option " + keys.join(".") + " is not defined in the options file.");
      }
      return defaultVal;
    }
    obj = obj[key];
  }
  return obj;
};


function _debug(message) {
  if (getSetting(['debug',],false)) {
    logger.info(message);
  }
}



// global variable to set the PA indicator color (as a css class)
/// {{#PAShowInfo}}
var paIndicator = (function () {
  let my = {};
  my.type = null;
  my.className = null;
  my.tooltip = null;

  if ('{{#PADoNotTest}}a{{/PADoNotTest}}{{#PASeparateWordCard}}a{{/PASeparateWordCard}}') {
    my.type = "none";
  } else if ('{{#PASeparateSentenceCard}}a{{/PASeparateSentenceCard}}{{#PATestOnlyWord}}a{{/PATestOnlyWord}}') {
    my.type = "word";
  } else if ('{{#IsSentenceCard}}a{{/IsSentenceCard}}') {
    my.type = "sentence";
  } else {
    my.type = "word";
  }

  my.className = "pa-indicator-color--" + my.type;

  if (my.type === "none") {
    my.tooltip = "Do not test"
  } else if (my.type == "word") {
    my.tooltip = "Word"
  } else { // sentence
    my.tooltip = "Sentence"
  }

  return my;
}());
/// {{/PAShowInfo}} // PAShowInfo


///  /// note.card_type != "pa_word"



/// 


/// 

// creates a custom image container to hold yomichan images
function createImgContainer(imgName) {
  // creating this programmically:
  // <span class="glossary__image-container">
  //   <a class="glossary__image-hover-text" href='javascript:;'>[Image]</a>
  //   <img class="glossary__image-hover-media" src="${imgName}">
  // </span>

  let defSpan = document.createElement('span');
  defSpan.classList.add("glossary__image-container");

  let defAnc = document.createElement('a');
  defAnc.classList.add("glossary__image-hover-text");
  defAnc.href = "javascript:;'>[Image]";
  defAnc.textContent = "[Image]";

  let defImg = document.createElement('img');
  defImg.classList.add("glossary__image-hover-media");
  defImg.src = imgName;

  defImg.onclick = function() {
    modal.style.display = "block";
    modalImg.src = this.src;
  }

  defAnc.onclick = function() {
    modal.style.display = "block";
    modalImg.src = defImg.src;
  }

  defSpan.appendChild(defAnc);
  defSpan.appendChild(defImg);

  return defSpan;
}

// https://github.com/FooSoft/anki-connect#javascript
function invoke(action, params={}) {
  let version = 6;
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.addEventListener('error', () => reject('failed to issue request'));
    xhr.addEventListener('load', () => {
      try {
        const response = JSON.parse(xhr.responseText);
        if (Object.getOwnPropertyNames(response).length != 2) {
          throw 'response has an unexpected number of fields';
        }
        if (!response.hasOwnProperty('error')) {
          throw 'response is missing required error field';
        }
        if (!response.hasOwnProperty('result')) {
          throw 'response is missing required result field';
        }
        if (response.error) {
          throw response.error;
        }
        resolve(response.result);
      } catch (e) {
        reject(e);
      }
    });

    xhr.open('POST', 'http://127.0.0.1:8765');
    xhr.send(JSON.stringify({action, version, params}));
  });
}



// functions relating to kanji hover

// multi query result, in the format of
// [kanji 1 (non-new), kanji 1 (new), kanji 2 (non-new), kanji 2 (new), etc.]
async function cardQueries(kanjiArr) {
  const cardTypeName = 'PA Word Card';

  function constructFindCardAction(query) {
    return {
      "action": "findCards",
      "params": {
        "query": query,
      }
    }
  }

  // constructs the multi findCards request for ankiconnect
  let actions = [];
  for (const character of kanjiArr) {
    const baseQuery = (
      `(-"Key:{{Key}}" -"WordReading:{{WordReading}}"`
      + `Word:*${character}* "card:${cardTypeName}") `
    );
    const nonNewQuery = baseQuery + getSetting(['kanji-hover','non-new-query',],'(-is:new OR (is:new flag:3)) -(is:suspended flag:1)');
    const newQuery = baseQuery + getSetting(['kanji-hover','new-query',],'is:new -(is:suspended (flag:1 OR flag:3))');

    //logger.warn(nonNewQuery)
    //logger.warn(newQuery)
    actions.push(constructFindCardAction(nonNewQuery))
    actions.push(constructFindCardAction(newQuery))
  }

  return await invoke("multi", {"actions": actions})
}

function filterCards(nonNewCardIds, newCardIds) {
  const nonNewEarliest = getSetting(['kanji-hover','max-non-new-oldest',],2);
  const nonNewLatest = getSetting(['kanji-hover','max-non-new-latest',],2);
  const newLatest = getSetting(['kanji-hover','max-new-latest',],2);

  // non new: gets the earliest and latest
  let nonNewResultIds = []
  if (nonNewCardIds.length > nonNewEarliest + nonNewLatest) {
    nonNewResultIds = [
      ...nonNewCardIds.slice(0, nonNewEarliest), // earliest
      ...nonNewCardIds.slice(-nonNewLatest, nonNewCardIds.length), // latest
    ];
  } else {
    nonNewResultIds = [...nonNewCardIds];
  }

  let newResultIds = newCardIds.slice(0, newLatest);

  return [nonNewResultIds, newResultIds];
}



async function getCardsInfo(queryResults) {
  function constructCardsInfoAction(idList) {
    return {
      "action": "cardsInfo",
      "params": {
        "cards": idList,
      }
    }
  }

  let actions = [];
  logger.assert(queryResults.length % 2 == 0, "query results not even");

  //for (const [i, character] of kanjiArr.entries()) {
  for (let i = 0; i < queryResults.length/2; i++) {
    // ids are equivalent to creation dates, so sorting ids is equivalent to
    // sorting to card creation date
    let nonNewCardIds = queryResults[i*2].sort();
    let newCardIds = queryResults[i*2 + 1].sort();
    let [nonNewResultIds, newResultIds] = filterCards(nonNewCardIds, newCardIds)

    // creates a multi request of the following format:
    // [cardInfo (nonNewCardIds, kanji 1), cardInfo (newCardIds, kanji 1), etc.]

    actions.push(constructCardsInfoAction(nonNewResultIds))
    actions.push(constructCardsInfoAction(newResultIds))
  }

  return await invoke("multi", {"actions": actions})
}


// taken directly from anki's implementation of { {furigana:...} }
// https://github.com/ankitects/anki/blob/main/rslib/src/template_filters.rs
function buildWordDiv(character, wordReading) {

  //let wrapper = document.createElement('div');

  let wordDiv = document.createElement('div');
  // TODO reading
  //let wordReading = card["fields"]["WordReading"]["value"];
  let re = / ?([^ >]+?)\[(.+?)\]/g

  //let wordReadingRuby = wordReading.replaceAll(re, function (matched) {
  //  logger.warn(matched);
  //  logger.warn(matched[1] + "--" + matched[2]);
  //  return `<ruby><rb>${matched[1]}</rb><rt>${matched[2]}</rt></ruby>`
  //});
  let wordReadingRuby = wordReading.replace(re, "<ruby><rb>$1</rb><rt>$2</rt></ruby>");
  //logger.warn(wordReadingRuby);
  wordReadingRuby = wordReadingRuby.replaceAll(character, `<b>${character}</b>`);

  wordDiv.innerHTML = wordReadingRuby;
  return wordDiv;

  //wrapper.appendChild(kanjiSpan);

  //return wrapper.innerHTML;
}

function buildSentDiv(sentence) {
  let sentenceSpan = document.createElement('span');

  let resultSent = sentence;
  //resultSent = resultSent.replace("<b>", "<u>");
  //resultSent = resultSent.replace("</b>", "</u>");
  resultSent = resultSent.replaceAll("<b>", "");
  resultSent = resultSent.replaceAll("</b>", "");
  sentenceSpan.innerHTML = resultSent;

  let openQuote = document.createElement('span');
  //openQuote.classList.add("sentence-quote--open");
  openQuote.innerText = "「";
  let closeQuote = document.createElement('span');
  //closeQuote.classList.add("sentence-quote--close");
  closeQuote.innerText = "」";


  let sentenceDiv = document.createElement('div');
  sentenceDiv.classList.add("left-align-quote");

  sentenceDiv.appendChild(openQuote);
  sentenceDiv.appendChild(sentenceSpan);
  sentenceDiv.appendChild(closeQuote);

  return sentenceDiv;
}

function buildCardDiv(character, card, isNew=false) {
  let cardDiv = document.createElement('div');
  // TODO
  //cardDiv.classList.add("kanji-hover-text")

  // TODO reading
  //let wordDiv = document.createElement('div');
  //wordDiv.innerText = card["fields"]["Word"]["value"];
  //logger.warn(JSON.stringify(card["fields"]["Word"]));
  let wordDiv = buildWordDiv(character, card["fields"]["WordReading"]["value"]);
  //buildWordDiv(card["fields"]["WordReading"]["value"]);

  //let sentenceDiv = document.createElement('div');
  //sentenceDiv.innerHTML = card["fields"]["Sentence"]["value"];
  let sentenceDiv = buildSentDiv(card["fields"]["Sentence"]["value"]);
  //logger.warn(sentenceDiv.innerHTML);

  cardDiv.appendChild(wordDiv);
  cardDiv.appendChild(sentenceDiv);

  if (isNew) {
    cardDiv.classList.add("kanji-hover-tooltip--new");
  }

  return cardDiv;
}

function buildString(character, nonNewCardInfo, newCardInfo) {

  /*
   * <span class="kanji-hover-wrapper">
   *   <span class="kanji-hover-text"> (kanji) </span>
   *   <span class="kanji-hover-tooltip-wrapper">
   *     <span class="kanji-hover-tooltip"> ... </span>
   *   </span>
   * </span>
   *
   */

  // wrapper element that isn't used, to get the inner html
  let wrapper = document.createElement('span');

  let kanjiHoverWrapper = document.createElement('span');
  kanjiHoverWrapper.classList.add("kanji-hover-wrapper");


  let kanjiSpan = document.createElement('span');
  kanjiSpan.classList.add("kanji-hover-text");
  kanjiSpan.innerText = character;

  tooltipWrapperSpan = document.createElement('span');
  tooltipWrapperSpan.classList.add("kanji-hover-tooltip-wrapper");

  tooltipSpan = document.createElement('span');
  tooltipSpan.classList.add("kanji-hover-tooltip");

  //logger.warn(character);
  let count = 0;


  for (let card of nonNewCardInfo) {
    //logger.warn(card);
    let cardDiv = buildCardDiv(character, card);
    if (count >= 1) {
      cardDiv.classList.add("kanji-hover-tooltip--not-first");
    }
    count++;

    tooltipSpan.appendChild(cardDiv);
  }

  for (let card of newCardInfo) {
    let cardDiv = buildCardDiv(character, card, isNew=true);
    if (count >= 1) {
      cardDiv.classList.add("kanji-hover-tooltip--not-first");
    }
    count++;

    tooltipSpan.appendChild(cardDiv);
  }


  // 0 length checks
  if (nonNewCardInfo.length + newCardInfo.length == 0) {
    tooltipSpan.innerText = "No other kanjis found.";
  }

  tooltipWrapperSpan.appendChild(tooltipSpan)
  kanjiHoverWrapper.appendChild(kanjiSpan);
  kanjiHoverWrapper.appendChild(tooltipWrapperSpan);
  wrapper.appendChild(kanjiHoverWrapper);

  return wrapper.innerHTML;
}


function getWordReadings(nonNewCardInfo, newCardInfo) {
  let wordsArr = []

  for (let card of nonNewCardInfo) {
    wordsArr.push(card["fields"]["WordReading"]["value"])
  }
  for (let card of newCardInfo) {
    wordsArr.push(card["fields"]["WordReading"]["value"])
  }

  //logger.warn(wordsArr.join(" "));
  return wordsArr;
}



// kanji hover
// some code shamelessly stolen from cade's kanji hover:
// https://github.com/cademcniven/Kanji-Hover/blob/main/_kanjiHover.js

// element outside async function to prevent double-adding due to anki funkyness
let wordReading = document.getElementById("dh_reading");

let kanjiHoverEnabled = false;

async function kanjiHover() {

  if (kanjiHoverEnabled) {
    _debug("Kanji hover already enabled");
    return;
  }
  kanjiHoverEnabled = true;

  // realistically, key should be good enough since we assume that key has no duplicates
  // however, just in case, wordreading is added
  let cacheKey = "{{Key}}.{{WordReading}}"
  if (cacheKey in kanjiHoverCardCache) {
    _debug("Card was cached")
    wordReading.innerHTML = kanjiHoverCardCache[cacheKey];
    //logger.info(`using cached card ${cacheKey}`);
    return;
  }

  let readingHTML = wordReading.innerHTML;

  // uses cache if it already exists
  let kanjiSet = new Set() // set of kanjis that requires api calls
  const regex = /([\u4E00-\u9FAF])(?![^<]*>|[^<>]*<\/g)/g;
  const matches = readingHTML.matchAll(regex);
  for (const match of matches) {
    kanjiSet.add(...match);
  }

  let kanjiDict = {};
  let wordReadings = {}; // used only for the cache

  // attempts to fill out the kanji dict with cached entries
  for (let kanji of [...kanjiSet]) {
    // also checks that the current word is not used
    if ((kanji in kanjiHoverCache) && !(kanjiHoverCache[kanji][0].includes("{{WordReading}}"))) {
      _debug(`Using cached kanji ${kanji}`)
      kanjiDict[kanji] = kanjiHoverCache[kanji][1];
      kanjiSet.delete(kanji);
    }
  }

  // only calls the api on the needed kanjis
  const kanjiArr = [...kanjiSet];
  const queryResults = await cardQueries(kanjiArr);
  const cardsInfo = await getCardsInfo(queryResults);

  _debug(`New kanjis: [${kanjiArr.join(", ")}]`)

  for (const [i, character] of kanjiArr.entries()) {
    let nonNewCardInfo = cardsInfo[i*2];
    let newCardInfo = cardsInfo[i*2 + 1];

    // attempts to insert string
    kanjiDict[character] = buildString(character, nonNewCardInfo, newCardInfo);
    wordReadings[character] = getWordReadings(nonNewCardInfo, newCardInfo);
  }

  let re = new RegExp(Object.keys(kanjiDict).join("|"), "gi");
  let resultHTML = readingHTML.replace(re, function (matched) {
    return kanjiDict[matched] ?? matched;
  });

  wordReading.innerHTML = resultHTML;

  // caches card
  kanjiHoverCardCache[cacheKey] = resultHTML;

  //_debug(resultHTML);

  for (let character of kanjiArr) {
    kanjiHoverCache[character] = [wordReadings[character], kanjiDict[character]];
  }

}




async function openExtraInfoIfNew() {

  // checks option first to see if it's enabled in the first place
  if ( !getSetting(['open-extra-info-when-new',],false)) {
    return;
  }

  // cancels if not new
  // refreshes on every new check, b/c one cannot assume that a card
  // is no longer new once you see a new card
  // (editing a new card will consistently refresh the currently new card)
  const key = "{{Key}}";
  if (key in isNewCardCache && !isNewCardCache[key]) {
    _debug("Key in new card cache and is not new");
    return;
  }

  // requires that any of PAGraphs and UtilityDictionaries be filled to even open extra info
  if (!'{{#PAGraphs}}a{{/PAGraphs}}{{#UtilityDictionaries}}a{{/UtilityDictionaries}}') {
    _debug("Neither PAGraphs nor UtilityDictionaries exists");
    return;
  }

  _debug("Testing for new card...");

  function constructFindCardAction(query) {
    return {
      "action": "findCards",
      "params": {
        "query": query,
      }
    }
  }

  // constructs the multi findCards request for ankiconnect
  let actions = [];
  actions.push(constructFindCardAction(`"Key:${key}"`));
  actions.push(constructFindCardAction(`is:new "Key:${key}"`));

  const multi = await invoke("multi", {"actions": actions});
  const cards = multi[0];

  if (cards.length > 1) {
    logger.warn("Duplicate key found.");
    return;
  }
  if (cards.length == 0) {
    logger.error("Open extra info if new: Cannot find its own card?");
    return;
  }

  const isNew = (multi[1].length > 0);
  isNewCardCache[key] = isNew;

  if (isNew) {
    _debug("Card is new, opening extra info...");
    let ele = document.getElementById("extra_info_details");
    if (ele) {
      toggleDetailsTag(ele)
    }
  } else {
    _debug("Card is not new.");
  }
}


/// 


/// 
/// 





// shift to switch between sentence & word on click & hover cards
// NOTICE: we MUST use document.onkeyup instead of document.addEventListener(...)
// because functions persist and cannot be easily removed within anki,
// whereas .onkeyup = ... replaces the previous function with the current.
document.onkeyup = (e => {
  let keys = null;
  let ele = null;

  // tests for the existance of extraKeybindSettings
  //if (typeof extraKeybindSettings !== 'undefined') {
  //  extraKeybindSettings(e);
  //}

  /// 
    /// 

    /// 


  /// 
  /// 
    /// 




  if (e.getModifierState && e.getModifierState('CapsLock')) {
    if ("CapsLock" === e.key) {
      // either just enabled or disabled
      logger.removeWarn("caps");
    } else {
      logger.warn("Caps lock is enabled. Keybinds may not work as expected.", true, "caps")
    }
  } else {
    //_debug("Caps lock is not enabled");
  }


  /// {{#WordAudio}}
  //keys = settings.keybind("play-word-audio");
  keys = getSetting(['keybinds','play-word-audio',],['w']);

  if (keys !== null && keys.includes(e.key)) {
    ele = document.querySelector("#word-audio .soundLink, #word-audio .replaybutton");
    if (ele) {
      ele.click();
    }
  }
  /// {{/WordAudio}}

  /// {{#SentenceAudio}}
  keys = getSetting(['keybinds','play-sentence-audio',],['p']);
  if (keys !== null && keys.includes(e.key)) {

    let hSent = document.getElementById("hybrid-sentence");

    /// 
      ele = document.querySelector("#sentence-audio .soundLink, #sentence-audio .replaybutton");
      if (ele) {
        ele.click();
      }
    /// 
  }
  /// {{/SentenceAudio}}

  keys = getSetting(['keybinds','toggle-front-full-sentence-display',],["'"]);
  ele = document.getElementById("full_sentence_front_details");
  if (keys !== null && ele && keys.includes(e.key)) {
    toggleDetailsTag(ele)
  }

  /// {{#Hint}}
  keys = getSetting(['keybinds','toggle-hint-display',],['.']);
  ele = document.getElementById("hint_details");
  if (keys !== null && ele && keys.includes(e.key)) {
    toggleDetailsTag(ele)
  }
  /// {{/Hint}}

  /// 
  /// {{#SecondaryDefinition}}
  keys = getSetting(['keybinds','toggle-secondary-definitions-display',],['8']);
  ele = document.getElementById("secondary_definition_details");
  if (keys !== null && ele && keys.includes(e.key)) {
    toggleDetailsTag(ele)
  }
  /// {{/SecondaryDefinition}}

  /// {{#AdditionalNotes}}
  keys = getSetting(['keybinds','toggle-additional-notes-display',],['9']);
  ele = document.getElementById("additional_notes_details");
  if (keys !== null && ele && keys.includes(e.key)) {
    toggleDetailsTag(ele)
  }
  /// {{/AdditionalNotes}}

  /// {{#ExtraDefinitions}}
  keys = getSetting(['keybinds','toggle-extra-definitions-display',],['0']);
  ele = document.getElementById("extra_definitions_details");
  if (keys !== null && ele && keys.includes(e.key)) {
    toggleDetailsTag(ele)
  }
  /// {{/ExtraDefinitions}}

  if ('{{#PAGraphs}}a{{/PAGraphs}}{{#UtilityDictionaries}}a{{/UtilityDictionaries}}') {
    keys = getSetting(['keybinds','toggle-extra-info-display',],['[']);
    ele = document.getElementById("extra_info_details");
    if (keys !== null && ele && keys.includes(e.key)) {
      toggleDetailsTag(ele)
    }
  }
  ///  

})


// sanity check
if (typeof JPMNOpts === 'undefined') {
  logger.warn("JPMNOpts was not defined in the options file. Was there an error?");
}

/// 


/// 

// checks leech
let tags = "{{Tags}}".split(" ");
if (tags.includes("leech")) {
  logger.leech();
}


// a bit of a hack...
// The only reason why the downstep arrow exists in the first place is to make the downstep
// mark visible while editing the field in anki. Otherwise, there is no reason for it to exist.
//let wp = document.getElementById("dh_word_pitch");
//wp.innerHTML = wp.innerHTML.replace(/&#42780/g, "").replace(/ꜜ/g, "");

// removes greyed out fields if they should be hidden
if ( !getSetting(['greyed-out-collapsable-fields-when-empty',],false)) {
  let elems = document.getElementsByClassName("glossary-details--grey");
  for (let x of elems) {
    x.style.display = "none";
  }
}





let modal = document.getElementById('modal');
let modalImg = document.getElementById("bigimg");

// restricting the max height of image to the definition box
let dhLeft = document.getElementById("dh_left");
let dhRight = document.getElementById("dh_right");
let heightLeft = dhLeft.offsetHeight;

if (dhRight) {
  dhRight.style.maxHeight = heightLeft + "px";

  // setting up the modal styles and clicking
  let dhImgContainer = document.getElementById("dh_img_container");
  let imgList = dhImgContainer.getElementsByTagName("img");

  if (imgList && imgList.length === 1) {
    let img = dhImgContainer.getElementsByTagName("img")[0];
    img.classList.add("dh-right__img");
    img.style.maxHeight = heightLeft + "px"; // restricts max height here too

    img.onclick = function() {
      modal.style.display = "block";
      modalImg.src = this.src;
    }

  } else { // otherwise we hope that there are 0 images here
    // support for no images here: remove the fade-in / fade-out on text
    // the slightly hacky method is just to remove the class all together lol
    dhImgContainer.className = "";
  }
}


// close the modal upon click
modal.onclick = function() {
  bigimg.classList.add("modal-img__zoom-out");
  modal.classList.add("modal-img__zoom-out");
  setTimeout(function() {
    modal.style.display = "none";
    bigimg.className = "modal-img";
    modal.className = "modal";
  }, 200);
}


// remove all jmdict english dict tags
//var glossaryEle = document.getElementById("primary_definition");
//glossaryEle.innerHTML = glossaryEle.innerHTML.replace(/, JMdict \(English\)/g, "");

// goes through each blockquote and searches for yomichan inserted images
let imageSearchElements = document.getElementsByTagName("blockquote");
for (let searchEle of imageSearchElements) {
  let anchorTags = searchEle.getElementsByTagName("a");
  for (let atag of anchorTags) {
    let imgFileName = atag.getAttribute("href");
    if (imgFileName && imgFileName.substring(0, 25) === "yomichan_dictionary_media") {
      let fragment = createImgContainer(imgFileName);
      atag.parentNode.replaceChild(fragment, atag);
    }
  }

  // looks for user inserted images
  let imgTags = searchEle.getElementsByTagName("img");
  for (let imgEle of imgTags) {
    if (!imgEle.classList.contains("glossary__image-hover-media")) { // created by us
      let fragment = createImgContainer(imgEle.src);
      imgEle.parentNode.replaceChild(fragment, imgEle);
    }
  }
}


// only continues if kanji-hover is actually enabled
if (getSetting(['kanji-hover','enabled',],true)) {
  if (getSetting(['kanji-hover','mode',],1) === 0) {
    kanjiHover();
  } else { // === 1
    wordReading.onmouseover = function() {
      // replaces the function with a null function to avoid calling this function
      wordReading.onmouseover = function() {}
      kanjiHover();
    }
  }
}

openExtraInfoIfNew();


//_debug(document.documentElement.innerHTML);

/// 


/// 
/// 

//})();


}());

</script>




