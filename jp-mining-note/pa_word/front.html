

{{#PASeparateWordCard}}
<!--
WARNING: This template is auto-generated.
Any changes to this template WILL BE LOST if you decide to update the card.
See https://aquafina-water-bottle.github.io/jp-mining-note/modding/
if you want to modify the card templates and css without losing your changes
upon updates.

JPMN-COMPILE-TIME-OPTIONS-JSON:
{
  "compile-options": {
    "allow-user-defined-modules": false,
    "always-filled-fields": [],
    "css-folders": [
      "base",
      "dictionaries"
    ],
    "enabled-modules": [
      "sent-utils",
      "kanji-hover",
      "auto-pitch-accent",
      "img-utils",
      "customize-open-fields"
    ],
    "hardcoded-runtime-options": false,
    "keybinds-enabled": true,
    "never-filled-fields": []
  }
}

-->


<script>


/* quick fix for legacy anki versions (replaces ?? operator) */
function nullish(a, b) {
  if ((typeof a === "undefined") || (a === null)) {
    return b;
  }
  return a;
}


/// 
function getSetting(keys, defaultVal) {
  if (typeof JPMNOpts === "undefined") {
    return defaultVal;
  }

  let keyList = ["settings"].concat(keys);

  let obj = JPMNOpts;
  for (let key of keyList) {
    if (!(key in obj)) {

      // checks if we need to warn, manual search
      if ("settings" in JPMNOpts && "debug" in JPMNOpts["settings"] && JPMNOpts["settings"]["debug"]) {
        LOGGER.warn("Option " + keys.join(".") + " is not defined in the options file.");
      }
      return defaultVal;
    }
    obj = obj[key];
  }
  return obj;
};
///  


var JPMNLogger = (() => {
  class JPMNLogger {
    constructor(name=null) {
      this._name = name;
      this._uniqueKeys = new Set();
    }


    error(message) {
      let groupEle = document.getElementById("info_circle_text_error");
      this._appendMsg(message, groupEle);
      let infoCirc = document.getElementById("info_circle");
      if (!infoCirc.classList.contains("info-circle-error")) {
        infoCirc.classList.add("info-circle-error")
      }
    }

    errorStack(stack) {
      try {
        let ignoredErrors = getSetting(['ignored-errors',],['ReferenceError: EFDRC is not defined.']);
        for (let substr of ignoredErrors) {
          if (stack.includes(substr)) {
            // ignores
            return;
          }
        }

        let stackList = stack.split(" at ");
        for (let i = 1; i < stackList.length; i++) {
          stackList[i] = ">>> " + stackList[i];
        }
        this.error(stackList);
      } catch (e) {
        // in case the above fails for some reason
        // better to throw an error that is not as prettily formatted
        // than to essentially have it go missing
        this.error(stack);
      }

    }


    assert(condition, message) {
      if (!condition) {
        this.error("(assert) " + message);
      }
    }

    removeWarn(key) {
      // assumes that this is a unique warn message

      if (!this._uniqueKeys.has(key)) {
        return;
      }

      let groupEle = document.getElementById("info_circle_text_warning");
      for (let e of groupEle.children) {
        if (e.getAttribute("data-key") === key) {
          groupEle.removeChild(e);
        }
      }

      let infoCirc = document.getElementById("info_circle");
      if (groupEle.children.length === 0 && infoCirc.classList.contains("info-circle-warning")) {
        infoCirc.classList.remove("info-circle-warning")
      }

      this._uniqueKeys.delete(key);
    }

    // key defaults to the message if unique is true and key is null
    // key is ignored if unique == false
    warn(message, unique=true, key=null) {

      // skips any non-unique warns as defined by the key
      if (unique) {
        if (key === null) {
          key = message;
        }

        if (this._uniqueKeys.has(key)) {
          return;
        }
      }

      let groupEle = document.getElementById("info_circle_text_warning");
      this._appendMsg(message, groupEle, key);
      let infoCirc = document.getElementById("info_circle");
      if (!infoCirc.classList.contains("info-circle-warning")) {
        infoCirc.classList.add("info-circle-warning");
      }

      if (key !== null) {
        this._uniqueKeys.add(key);
      }

    }

    info(message) {
      let groupEle = document.getElementById("info_circle_text_info");
      this._appendMsg(message, groupEle);
    }

    debug(message) {
      if (getSetting(['debug',],false)) {
        this.info(message);
      }
    }

    leech() {
      let groupEle = document.getElementById("info_circle_text_leech");
      this._appendMsg("", groupEle);
      let infoCirc = document.getElementById("info_circle");
      if (!infoCirc.classList.contains("info-circle-leech")) {
        infoCirc.classList.add("info-circle-leech");
      }
    }

    _appendMsg(message, groupEle, key=null) {
      // I think this stops an infinite loop somewhere if you log a null for some reason...
      if (message === null) {
        message = "null";
      }

      if (this._name !== null) {
        message = `(${this._name}) ${message}`;
      }

      let msgEle = document.createElement('div');
      msgEle.classList.add("info-circle__message")
      if (key !== null) {
        msgEle.setAttribute("data-key", key);
      }

      if (Array.isArray(message)) {
        if (message.length > 0) {
          msgEle.textContent = message[0];

          for (let line of message.slice(1)) {
            let lineEle = document.createElement('div');
            lineEle.textContent = line;
            msgEle.appendChild(lineEle);
          }
        }

      } else {
        msgEle.textContent = message;
      }
      groupEle.appendChild(msgEle);
    }

  }

  return JPMNLogger;
})();


/* global logger object for any javascript outside of modules that needs logging */
var LOGGER = new JPMNLogger();


// on any javascript error: log it
window.onerror = function(msg, url, lineNo, columnNo, error) {
  LOGGER.errorStack(error.stack);
}

// https://stackoverflow.com/a/55178672
window.onunhandledrejection = function(errorEvent) {
  LOGGER.error("Javascript handler error: `" + errorEvent.reason + "`");
}


function optionsNotFound() {
  LOGGER.warn("Options file not found. Did you place the options file in the media directory?");
}



</script>


<script onerror="optionsNotFound();" src="_jpmn-options.js"></script>
 


<div class="card-description">


    

    
  PA Word


    
  <span class="info-circle" id="info_circle">
    <span class="info-circle-svg-wrapper">
      <svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" class="bi bi-info-circle" viewBox="0 0 16 16">
        <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
        <path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
      </svg>
    </span>

    <span class="info-circle-text-wrapper">
      <span class="info-circle-text" id="info_circle_text">
        <div class="info-circle-text-error" id="info_circle_text_error"></div>
        <div class="info-circle-text-warning" id="info_circle_text_warning"></div>
        <div class="info-circle-text-leech" id="info_circle_text_leech"></div>
        <div class="info-circle-text-info" id="info_circle_text_info">
          <div>
            Need help? View the
            <a href="https://aquafina-water-bottle.github.io/jp-mining-note/">documentation</a>.
          </div>
          <div>
            Have an issue?
            <a href="https://github.com/Aquafina-water-bottle/jp-mining-note/issues">Report it here</a>.
          </div>
          <div>
            View the
            <a href="https://github.com/Aquafina-water-bottle/jp-mining-note">source code</a>.
          </div>
        </div>
      </span>
    </span>
  </span>

    
  <!-- DO NOT CHANGE/REMOVE THIS: this is used to record the version when updating the note. -->
  <div class="card-description-ver">JP Mining Note: Version 0.10.2.1</div>


</div>










<!-- note that for the PA separate word card, the front is ALWAYS a word -->
<!-- priority: AltDisplay -> Word -->

<!-- option 1: AltDisplay (only if the original card is not a sentence card or hybrid card) -->
<div class="outer-display1
    {{^IsClickCard}}{{^IsHoverCard}}{{^IsSentenceCard}}{{^IsTargetedSentenceCard}}
    {{#AltDisplay}}
      outer-display2
    {{/AltDisplay}}
    {{/IsTargetedSentenceCard}}{{/IsSentenceCard}}{{/IsHoverCard}}{{/IsClickCard}}
    "
  id="display">

  <!-- if NOT (altdisplay, AND none of (click, hover, sentence, TSC)) -->
  <div class="expression expression--single expression--word inner-display1">
    {{Word}}
  </div>

  <!-- if altdisplay, AND none of (click, hover, sentence, TSC) -->
  <div class="expression expression--single expression--word inner-display2">
    {{furigana:AltDisplay}}
  </div>
</div>


{{#HintNotHidden}}
  <div class="center-box-1 hint">
    <div class="center-box-2">
      <div class="highlight-bold">{{HintNotHidden}}</div>
    </div>
  </div>
{{/HintNotHidden}}

<!-- https://stackoverflow.com/questions/1269589/css-center-block-but-align-contents-to-the-left -->
<!-- tl;dr wrap anything you want centered + left justified with center-box-1 and center-box-2 -->
{{#Hint}}
  <details class="hint" id="hint_details">
    <summary>Hint</summary>
    <div class="center-box-1">
      <div class="center-box-2">
        <div class="highlight-bold">{{Hint}}</div>
      </div>
    </div>
  </details>
{{/Hint}}





<script>









// GLOBALS: kanji-hover


// global cache for an entire card's kanji hover html
// maps key.word_reading -> html string
//var kanjiHoverCardCache = kanjiHoverCardCache ?? {};
var kanjiHoverCardCache = nullish(kanjiHoverCardCache, {});

// maps kanji -> [{set of used words}, html string]
//var kanjiHoverCache = kanjiHoverCache ?? {};
var kanjiHoverCache = nullish(kanjiHoverCache, {});


/// 







// GLOBALS: customize-open-fields


// note that this cache will NOT respect card review undos,
// but that should be a niche enough case to not warrent caching.
// maps key -> bool
var isNewCardCache = nullish(isNewCardCache, {});

/// 





(function () { // restricts ALL javascript to hidden scope

// "global" variables within the hidden scope
let note = (function () {
  let my = {};
  return my;
}());



/*
 * Toggles the display of any given details tag
 */
function toggleDetailsTag(ele) {
  if (ele.hasAttribute('open')) {
    ele.removeAttribute('open');
  } else {
    ele.setAttribute("open", "true");
  }
}


// START_BLOCK: js_functions


// END_BLOCK: js_functions






























// a general function to implement all keybinds necessary by the card.
// NOTICE: we MUST use document.onkeyup instead of document.addEventListener(...)
// because functions persist and cannot be easily removed within anki,
// whereas .onkeyup = ... replaces the previous function with the current.
document.onkeyup = (e => {
  let keys = null;
  let ele = null;

  // START_BLOCK: js_keybind_settings




  // END_BLOCK: js_keybind_settings














  if (e.getModifierState && e.getModifierState('CapsLock')) {
    if (e.key === "CapsLock") {
      // either just enabled or disabled, not sure which one is which
      // it seems like normal browsers can't reach this point during (caps lock enabled -> caps lock disabled...)
      LOGGER.removeWarn("caps");
    } else if (!["Meta"].includes(e.key)) {
      LOGGER.debug(e.key);
      LOGGER.warn("Caps lock is enabled. Keybinds may not work as expected.", true, "caps")
    }
  } else {
    LOGGER.removeWarn("caps");
  }


  /// {{#WordAudio}}
  keys = getSetting(['keybinds','play-word-audio',],['w']);

  if (keys !== null && keys.includes(e.key)) {
    ele = document.querySelector("#word-audio .soundLink, #word-audio .replaybutton");
    if (ele) {
      ele.click();
    }
  }
  /// {{/WordAudio}}

  /// {{#SentenceAudio}}
  keys = getSetting(['keybinds','play-sentence-audio',],['p']);
  if (keys !== null && keys.includes(e.key)) {

    let hSent = document.getElementById("hybrid-sentence");

    /// 
      ele = document.querySelector("#sentence-audio .soundLink, #sentence-audio .replaybutton");
      if (ele) {
        ele.click();
      }
    /// 
  }
  /// {{/SentenceAudio}}

  keys = getSetting(['keybinds','toggle-front-full-sentence-display',],["'"]);
  ele = document.getElementById("full_sentence_front_details");
  if (keys !== null && ele && keys.includes(e.key)) {
    toggleDetailsTag(ele)
  }

  /// {{#Hint}}
  keys = getSetting(['keybinds','toggle-hint-display',],['.']);
  ele = document.getElementById("hint_details");
  if (keys !== null && ele && keys.includes(e.key)) {
    toggleDetailsTag(ele)
  }
  /// {{/Hint}}

  ///  

})
///  


function main() {

  // sanity check: options
  /// 
  if (typeof JPMNOpts === 'undefined') {
    LOGGER.warn("JPMNOpts was not defined in the options file. Was there an error?");
  }
  ///  

  // sanity check: checks that both `IsHoverCard` and `IsClickCard` are both not activated
  /// {{#IsHoverCard}}
  /// {{#IsClickCard}}
  LOGGER.warn("Both `IsHoverCard` and `IsClickCard` are filled. At most one should be filled at once.");
  /// {{/IsClickCard}}
  /// {{/IsHoverCard}}

  // START_BLOCK: js_run




  // END_BLOCK: js_run













}



main();



}());

</script>



{{/PASeparateWordCard}}
