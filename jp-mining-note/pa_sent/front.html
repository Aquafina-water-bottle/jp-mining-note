

{{#PASeparateSentenceCard}}
{{#SentenceAudio}}
<!--
WARNING: This template is auto-generated.
Any changes to this template WILL BE LOST if you decide to update the card.
See https://aquafina-water-bottle.github.io/jp-mining-note/modding/
if you want to modify the card templates and css without losing your changes
upon updates.

JPMN-COMPILE-TIME-OPTIONS-JSON:
{
  "compile-options": {
    "allow-user-defined-modules": false,
    "always-filled-fields": [],
    "css-folders": [
      "base",
      "responsive",
      "dictionaries"
    ],
    "enabled-modules": [
      "sent-utils",
      "kanji-hover",
      "auto-pitch-accent",
      "img-utils",
      "customize-open-fields",
      "word-indicators",
      "info-circle-utils",
      "fix-ruby-positioning",
      "check-duplicate-key"
    ],
    "external-links": {
      "image_search": {
        "hover-display": "google.co.jp (Image search)",
        "icon-image-dark": "_icon_image_white.svg",
        "icon-image-light": "_icon_image_black.svg",
        "icon-type": "image",
        "url": "https://www.google.co.jp/search?q={{text:Word}}\u0026tbm=isch"
      },
      "jisho.org": {
        "icon-image-dark": "_icon_jisho_darkmode.png",
        "icon-image-light": "_icon_jisho_lightmode.png",
        "icon-type": "image",
        "url": "https://jisho.org/search/{{Word}}"
      },
      "jpdb.io": {
        "icon-image-dark": "_icon_jpdb_darkmode.png",
        "icon-image-light": "_icon_jpdb_lightmode.png",
        "icon-type": "image",
        "url": "https://jpdb.io/search?q={{text:Word}}"
      }
    },
    "external-links-position": "Extra Info",
    "hardcoded-runtime-options": false,
    "keybinds-enabled": true,
    "never-filled-fields": []
  },
  "modules-used": [
    "sent-utils",
    "kanji-hover",
    "tooltip-builder",
    "anki-connect-actions",
    "auto-pitch-accent",
    "jp-utils",
    "img-utils",
    "customize-open-fields",
    "word-indicators",
    "info-circle-utils",
    "fix-ruby-positioning",
    "check-duplicate-key"
  ]
}

-->


<script>


/* quick fix for legacy anki versions (replaces ?? operator) */
function nullish(a, b) {
  if ((typeof a === "undefined") || (a === null)) {
    return b;
  }
  return a;
}

function isMobile() {
  return document.documentElement.classList.contains('mobile');
}

function getKeyPath(keys) {
  if (typeof keys === "string") {
    return keys;
  }
  return keys.join(".");
}

// placed outside as a global variable
var VW = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0)

// keys can be a string, or array of strings
function parseSetting(obj, keys) {
  // checks for an object with "type"
  // https://stackoverflow.com/a/8511350
  if (
    typeof obj === 'object' &&
    !Array.isArray(obj) &&
    obj !== null &&
    "type" in obj
  ) {
    if (obj.type === "pc-mobile") {
      if (isMobile()) {
        return obj["mobile"];
      } else {
        return obj["pc"];
      }
    } else if (obj.type === "viewport-width-is") {
      if (VW > obj["value"]) {
        return obj["greater"];
      } else {
        return obj["lesser"];
      }

    } else {
      LOGGER.warn(`Unknown type ${obj.type} for Option ${getKeyPath(keys)}. Using the entire object instead...`);
      return obj;
    }
  }

  return obj;
}


/// 
function getSetting(keys, defaultVal) {
  if (typeof JPMNOpts === "undefined") {
    return parseSetting(defaultVal, keys);
  }

  let keyList = ["settings"].concat(keys);

  let obj = JPMNOpts;
  for (let key of keyList) {
    if (!(key in obj)) {

      // checks if we need to warn, manual search
      if ("settings" in JPMNOpts && "debug" in JPMNOpts["settings"] && JPMNOpts["settings"]["debug"]) {
        LOGGER.warn("Option " + keys.join(".") + " is not defined in the options file.");
      }
      return parseSetting(defaultVal, keys);
    }
    obj = obj[key];
  }

  return parseSetting(obj, keys);
};
///  


var JPMNLogger = (() => {
  class JPMNLogger {
    constructor(name=null) {
      this._name = name;
      this._uniqueKeys = new Set();
    }


    error(message, isHtml=false) {
      let groupEle = document.getElementById("info_circle_text_error");
      this._appendMsg(message, groupEle, isHtml);
      let infoCirc = document.getElementById("info_circle");
      infoCirc.classList.toggle("info-circle-error", true)
    }

    errorStack(stack) {
      try {
        let ignoredErrors = getSetting(['ignored-errors',],['ReferenceError: EFDRC is not defined.']);
        for (let substr of ignoredErrors) {
          if (stack.includes(substr)) {
            // ignores
            return;
          }
        }

        let stackList = stack.split(" at ");
        for (let i = 1; i < stackList.length; i++) {
          stackList[i] = ">>> " + stackList[i];
        }
        this.error(stackList);
      } catch (e) {
        // in case the above fails for some reason
        // better to throw an error that is not as prettily formatted
        // than to essentially have it go missing
        this.error(stack);
      }

    }


    assert(condition, message) {
      if (!condition) {
        this.error("(assert) " + message);
      }
    }

    removeWarn(key) {
      // assumes that this is a unique warn message

      if (!this._uniqueKeys.has(key)) {
        return;
      }

      let groupEle = document.getElementById("info_circle_text_warning");
      for (let e of groupEle.children) {
        if (e.getAttribute("data-key") === key) {
          groupEle.removeChild(e);
        }
      }

      let infoCirc = document.getElementById("info_circle");
      if (groupEle.children.length === 0) {
        infoCirc.classList.toggle("info-circle-warning", false)
      }

      this._uniqueKeys.delete(key);
    }

    // key defaults to the message if unique is true and key is null
    // key is ignored if unique == false
    // TODO extend functionality of uniqueness to other logger functions
    // TODO change to args struct
    warn(message, isHtml=false, unique=false, key=null) {

      // skips any non-unique warns as defined by the key
      if (unique) {
        if (key === null) {
          key = message;
        }

        if (this._uniqueKeys.has(key)) {
          return;
        }
      }

      let groupEle = document.getElementById("info_circle_text_warning");
      this._appendMsg(message, groupEle, isHtml, key);
      let infoCirc = document.getElementById("info_circle");
      infoCirc.classList.toggle("info-circle-warning", true);

      if (key !== null) {
        this._uniqueKeys.add(key);
      }

    }

    info(message) {
      let groupEle = document.getElementById("info_circle_text_info");
      this._appendMsg(message, groupEle);
    }

    // higher the level -> more severe
    // i.e. lower levels == more messages
    // currently goes from 0 - 5:
    debug(message, level=3) {
      if (level >= getSetting(['debug-level',],6)) {
        let groupEle = document.getElementById("info_circle_text_debug");
        this._appendMsg(message, groupEle);
      }
    }

    leech() {
      let groupEle = document.getElementById("info_circle_text_leech");
      this._appendMsg("", groupEle);
      let infoCirc = document.getElementById("info_circle");
      infoCirc.classList.toggle("info-circle-leech", true);
    }

    _appendMsg(message, groupEle, isHtml=false, key=null) {
      // I think this stops an infinite loop somewhere if you log a null for some reason...
      if (message === null) {
        message = "null";
      }

      if (this._name !== null) {
        message = `(${this._name}) ${message}`;
      }

      let msgEle = document.createElement('div');
      msgEle.classList.add("info-circle__message")
      if (key !== null) {
        msgEle.setAttribute("data-key", key);
      }

      if (Array.isArray(message)) {
        if (message.length > 0) {
          msgEle.textContent = message[0];

          for (let line of message.slice(1)) {
            let lineEle = document.createElement('div');
            lineEle.textContent = line;
            msgEle.appendChild(lineEle);
          }
        }

      } else {
        if (isHtml) {
          msgEle.innerHTML = message;
        } else {
          msgEle.textContent = message;
        }
      }
      groupEle.appendChild(msgEle);
    }

  }

  return JPMNLogger;
})();


/* global logger object for any javascript outside of modules that needs logging */
var LOGGER = new JPMNLogger();


// on any javascript error: log it
window.onerror = function(msg, url, lineNo, columnNo, error) {
  LOGGER.errorStack(error.stack);
}

// https://stackoverflow.com/a/55178672
window.onunhandledrejection = function(errorEvent) {
  if (errorEvent.reason === "AnkiConnect failed to issue request.") {
    let reason = errorEvent.reason + ' Click <a href="https://aquafina-water-bottle.github.io/jp-mining-note/faq/#error-ankiconnect-failed-to-issue-request">here</a> for basic troubleshooting.';
    LOGGER.error("Javascript handler error: " + reason, /*isHtml=*/true);
  } else {
    LOGGER.error("Javascript handler error: " + errorEvent.reason);
  }
}


function optionsNotFound() {
  LOGGER.warn("Options file not found. Did you place the options file in the media directory?");
}



</script>


<script onerror="optionsNotFound();" src="_jpmn-options.js"></script>
 

<div class="hidden">
  <div id="hidden_key">{{Key}}</div>
  <div id="hidden_word_reading">{{WordReading}}</div>
  <div id="hidden_sentence">{{Sentence}}</div>
</div>



<div class="card-description">


    <span class="card-description__card-type">
    

    
  PA Sentence

    </span>

    
  <span class="info-circle info-circle--hover-color" id="info_circle">
    <span class="info-circle-svg-wrapper info-circle-svg-wrapper--hoverable", id="info_circle_wrapper">


      <svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" class="info-circle-svg" viewBox="0 0 16 16">
        <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
        <path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
      </svg>


    </span>

    <span class="info-circle-text-wrapper" id="info_circle_text_wrapper">
      <span class="info-circle-text" id="info_circle_text">
        <div class="info-circle-text-settings" id="info_circle_text_settings"></div>
        <div class="info-circle-text-settings-border"></div>

        <div class="info-circle-text-error" id="info_circle_text_error"></div>
        <div class="info-circle-text-warning" id="info_circle_text_warning"></div>
        <div class="info-circle-text-leech" id="info_circle_text_leech"></div>

        <div class="info-circle-text-info" id="info_circle_text_info">
          <div>
            Need help? View the
            <a href="https://aquafina-water-bottle.github.io/jp-mining-note/">documentation</a>.
          </div>
          <div>
            Have an issue?
            <a href="https://github.com/Aquafina-water-bottle/jp-mining-note/issues">Report it here</a>.
          </div>
          <div>
            View the
            <a href="https://github.com/Aquafina-water-bottle/jp-mining-note">source code</a>.
          </div>
        </div>

        <div class="info-circle-text-debug" id="info_circle_text_debug"></div>

      </span>

    </span>
  </span>

    
  <!-- DO NOT CHANGE/REMOVE THIS: this is used to record the version when updating the note. -->
  <div class="card-description-ver">JP Mining Note: Version 0.11.0.0</div>


</div>










<!-- note that for the PA separate sentence card, the front is ALWAYS a sentence -->
<!-- priority: AltDisplayPASentenceCard -> AltDisplay -> Sentence -->

<!-- option 1: AltDisplayPASentenceCard -->
{{#AltDisplayPASentenceCard}}
  <div class="expression expression--single expression--sentence" id="display">
    <span class="sentence-quote sentence-quote--open">「</span><span>{{furigana:AltDisplayPASentenceCard}}</span><span class="sentence-quote sentence-quote--close">」</span>
  </div>
{{/AltDisplayPASentenceCard}}

{{^AltDisplayPASentenceCard}}
  {{#AltDisplay}}

    <div class="outer-display1
        {{^IsClickCard}}{{^IsHoverCard}}{{^IsSentenceCard}}{{^IsTargetedSentenceCard}}
          outer-display2
        {{/IsTargetedSentenceCard}}{{/IsSentenceCard}}{{/IsHoverCard}}{{/IsClickCard}}
        "
      style="display: inline-block;" id="display">

      <!-- option 2: AltDisplay (only if the original card is a (sentence card or TSC or click or hybrid)) -->
      <!-- if any of (click, hover, sentence, TSC) -->
      <div class="expression expression--single expression--sentence inner-display1">
        <span class="sentence-quote sentence-quote--open">「</span><span>{{furigana:AltDisplay}}</span><span class="sentence-quote sentence-quote--close">」</span>
      </div>

      <!-- if none of (click, hover, sentence, TSC) -->
      <div class="expression expression--single expression--sentence inner-display2">
        <span class="sentence-quote sentence-quote--open">「</span><span>{{Sentence}}</span><span class="sentence-quote sentence-quote--close">」</span>
      </div>
    </div>

  {{/AltDisplay}}

  {{^AltDisplay}}
    <div class="expression expression--single expression--sentence" id="display">
      <span class="sentence-quote sentence-quote--open">「</span><span>{{Sentence}}</span><span class="sentence-quote sentence-quote--close">」</span>
    </div>
  {{/AltDisplay}}


{{/AltDisplayPASentenceCard}}


{{#HintNotHidden}}
  <div class="center-box-1 hint">
    <div class="center-box-2">
      <div class="highlight-bold">{{HintNotHidden}}</div>
    </div>
  </div>
{{/HintNotHidden}}

<!-- https://stackoverflow.com/questions/1269589/css-center-block-but-align-contents-to-the-left -->
<!-- tl;dr wrap anything you want centered + left justified with center-box-1 and center-box-2 -->
{{#Hint}}
  <details class="hint" id="hint_details">
    <summary>Hint</summary>
    <div class="center-box-1">
      <div class="center-box-2">
        <div class="highlight-bold">{{Hint}}</div>
      </div>
    </div>
  </details>
{{/Hint}}


<div class="popup-menu" id="popup_menu"></div>

<script>



// v1.0.0 - https://github.com/SimonLammer/anki-persistence/blob/cd2ca88e019dc3b8f32dad623932c1eabdba7e21/script.js
if(void 0===window.Persistence){var _persistenceKey="github.com/SimonLammer/anki-persistence/",_defaultKey="_default";if(window.Persistence_sessionStorage=function(){var e=!1;try{"object"==typeof window.sessionStorage&&(e=!0,this.clear=function(){for(var e=0;e<sessionStorage.length;e++){var t=sessionStorage.key(e);0==t.indexOf(_persistenceKey)&&(sessionStorage.removeItem(t),e--)}},this.setItem=function(e,t){null==t&&(t=e,e=_defaultKey),sessionStorage.setItem(_persistenceKey+e,JSON.stringify(t))},this.getItem=function(e){return null==e&&(e=_defaultKey),JSON.parse(sessionStorage.getItem(_persistenceKey+e))},this.removeItem=function(e){null==e&&(e=_defaultKey),sessionStorage.removeItem(_persistenceKey+e)})}catch(e){}this.isAvailable=function(){return e}},window.Persistence_windowKey=function(e){var t=window[e],n=!1;"object"==typeof t&&(n=!0,this.clear=function(){t[_persistenceKey]={}},this.setItem=function(e,n){null==n&&(n=e,e=_defaultKey),t[_persistenceKey][e]=n},this.getItem=function(e){return null==e&&(e=_defaultKey),null==t[_persistenceKey][e]?null:t[_persistenceKey][e]},this.removeItem=function(e){null==e&&(e=_defaultKey),delete t[_persistenceKey][e]},null==t[_persistenceKey]&&this.clear()),this.isAvailable=function(){return n}},window.Persistence=new Persistence_sessionStorage,Persistence.isAvailable()||(window.Persistence=new Persistence_windowKey("py")),!Persistence.isAvailable()){var titleStartIndex=window.location.toString().indexOf("title"),titleContentIndex=window.location.toString().indexOf("main",titleStartIndex);titleStartIndex>0&&titleContentIndex>0&&titleContentIndex-titleStartIndex<10&&(window.Persistence=new Persistence_windowKey("qt"))}}

// for testing purposes
//Persistence.isAvailable = function() {return false;}







// GLOBALS: kanji-hover


// global cache for an entire card's kanji hover html
// maps key.word_reading -> html string
var kanjiHoverCardCache = nullish(kanjiHoverCardCache, {});

// maps kanji -> [{set of used words}, html string]
var kanjiHoverCache = nullish(kanjiHoverCache, {});


/// 





// GLOBALS: anki-connect-actions


// note that this cache will NOT respect card review undos,
// but that should be a niche enough case to not warrent caching.
// maps cacheKey -> bool
var isNewCardCache = nullish(isNewCardCache, {});

// maps card_id -> (card info retrieved by Anki-Connect)
var cardsInfoCache = nullish(cardsInfoCache, {});

// maps query_str -> [card ids]
var cardQueryCache = nullish(cardQueryCache, {});

// maps key.sentence -> card id
var cardIdCache = nullish(cardIdCache, {});

/// 











// GLOBALS: word-indicators


//var sameReadingCardCache = nullish(sameReadingCardCache, {});
var similarWordsCardCache = nullish(similarWordsCardCache, {});

/// 







// GLOBALS: check-duplicate-key



// contains all unique keys
var uniqueKeysCache = nullish(uniqueKeysCache, []);

/// 






(function () { // restricts ALL javascript to hidden scope




const TAGS_LIST = "{{Tags}}".split(" ");


// "global" variables within the hidden scope
let note = (function () {
  let my = {};
  return my;
}());



/*
 * Toggles the display of any given details tag
 */
function toggleDetailsTag(ele) {
  if (ele.hasAttribute('open')) {
    ele.removeAttribute('open');
  } else {
    ele.setAttribute("open", "true");
  }
}

function popupMenuMessage(message, isHTML=false) {
  let popupMenu = document.getElementById("popup_menu");

  // creates message
  const popupMessageDiv = document.createElement("div");
  if (isHTML) {
    popupMessageDiv.innerHTML = message;
  } else {
    popupMessageDiv.innerText = message;
  }
  popupMessageDiv.classList.add("popup-menu--animate");

  popupMenu.appendChild(popupMessageDiv);

  // kills the popup after the animations play
  setTimeout(() => {
    popupMenu.removeChild(popupMessageDiv);
    LOGGER.debug(`Removed popup: "${message}"`, 2);
  }, 1000*(0.6+3+0.75))
}



// START_BLOCK: js_functions


// END_BLOCK: js_functions






// ================
//  Sentence Utils
// ================
//
// processes the sentence
// - removes newlines
// - replaces bold with [...] if cloze deletion
// - handles adding or replacing quotes if specified

const JPMNSentUtils = (() => {
  const logger = new JPMNLogger("sent-utils");

  function processSentence(sentEle, isAltDisplay, isClozeDeletion, paIndicator) {
    if (typeof isAltDisplay === 'undefined') {
      LOGGER.warn("isAltDisplay is undefined");
      isAltDisplay = false;
    }

    // ASSUMPTION: all sentence elements are formatted as [quote, sentence, quote]
    let result = sentEle.children[1].innerHTML;

    // removes leading and trailing white space (equiv. of strip() in python)
    result = result.trim();

    // cloze deletion replacing bold with [...]
    if (typeof isClozeDeletion !== "undefined" && isClozeDeletion) {
      result = result.replace(/<b>.*?<\/b>/g, "<b>[...]</b>");
    }

    // removes newlines

    // removes the final period if exists
    if ((getSetting(['modules','sent-utils','remove-final-period',],true) && !isAltDisplay)
      || (getSetting(['modules','sent-utils','remove-final-period-on-altdisplay',],false) && isAltDisplay)) {
      result = result.replace(/[｡。．\.]$/, "");
    }

    let validQuotes = getSetting(['modules','sent-utils','quote-match-strings',],[['「', '」'], ['『', '』']]);
    let existingQuote = false;

    let openQuoteEle = sentEle.children[0];
    let closeQuoteEle = sentEle.children[2];

    for (let quotePair of validQuotes) {
      if ((result[0] === quotePair[0]) && (result[result.length-1] === quotePair[1])) {

        // adds quote to surrounding divs
        let openQuote = null;
        let closeQuote = null;
        [openQuote, closeQuote] = quotePair;
        openQuoteEle.innerText = openQuote;
        closeQuoteEle.innerText = closeQuote;

        result = result.slice(1, -1);
        existingQuote = true;
        break;
      }
    }

    let autoQuote = (
      (!isAltDisplay && getSetting(['modules','sent-utils','auto-quote-sentence',],true))
      || (isAltDisplay && getSetting(['modules','sent-utils','auto-quote-alt-display-sentence',],true))
    );
    if (!existingQuote && autoQuote) {
      /// 
      openQuoteEle.innerText = getSetting(['modules','sent-utils','pa-sent-auto-quote-open',],'『');
      closeQuoteEle.innerText = getSetting(['modules','sent-utils','pa-sent-auto-quote-close',],'』');
      /// 
    }

    // no quotes are added
    if (!existingQuote && !autoQuote) {
      // note that it defaults to having quotes + auto align without this module being ran
      // hence why all these steps have to be done
      openQuoteEle.innerText = "";
      closeQuoteEle.innerText = "";

      sentEle.style["text-indent"] = "0em";
      sentEle.style["padding-left"] = "0em";
    }

    // removes the hover effect for mobile displays only
    ///
    /// {{#IsClickCard}}
    if (isMobile()) {
      document.getElementById("display").classList.toggle(
        "expression__hybrid--click-hover-effect", false);
    }
    /// {{/IsClickCard}}

    // data-color-quotes: INDICATOR if the sentence quotes are colored or not
    // - attribute doesn't exist by default
    // - if exists, then the quotes are colored
    // - added in the sections below:

    /// 
    if ((existingQuote || autoQuote) && getSetting(['modules','sent-utils','pa-sent-pa-indicator-color-quotes',],{"type": "viewport-width-is", "value": 1300, "greater": false, "lesser": true})) {
      openQuoteEle.classList.add("pa-indicator-color--sentence");
      closeQuoteEle.classList.add("pa-indicator-color--sentence");

      sentEle.setAttribute("data-color-quotes", "true");
    }
    /// 

    /// 

    sentEle.children[1].innerHTML = result;

  }


  class JPMNSentUtils {
    constructor(isAltDisplay, isClozeDeletion, paIndicator) {
      // TODO change isAltDisplay and isCloseDeletion to be set as an attribute
      // somewhere in the HTML rather than javascript

      this.isAltDisplay = isAltDisplay;
      this.isClozeDeletion = nullish(isClozeDeletion, false);
      this.paIndicator = nullish(paIndicator, null);
    }

    run() {
      let sentences = document.querySelectorAll(".expression--sentence")

      if (sentences !== null) {
        for (let sent of sentences) {
          processSentence(sent, this.isAltDisplay, this.isClozeDeletion, this.paIndicator);
        }
      }
    }
  }


  return JPMNSentUtils;

})();


/// 





































// =============
//  Image Utils
// =============

const JPMNImgUtils = (() => {

  const logger = new JPMNLogger("img-utils");

  const modal = document.getElementById('modal');
  const modalImg = document.getElementById("bigimg");

  const dhLeft = document.getElementById("dh_left");
  const dhLeftAudioBtns = document.getElementById("dh_left_audio_buttons");
  const primaryDefText = document.getElementById("primary_definition_text");
  const primaryDefPicEle = document.getElementById("primary_definition_picture")
  const primaryDefExtLinks = document.getElementById("external_links_primary_def_float");
  let HEIGHT_LEFT = 0;
  let TEXT_HEIGHT = 0
  let PIC_HEIGHT = 0
  let FLOAT_PIC_HEIGHT = 0


  const dhRight = document.getElementById("dh_right");
  const imgEye = document.getElementById("img_svg_eye"); // null on the front
  const imgEyePathEle = imgEye === null ? null : imgEye.children[0];
  const dhImgContainer = document.getElementById("dh_img_container");
  const dhImgBlur = document.getElementById("dh_img_container_nsfw_blur");


  // adjusts height even if it's tablet mode because the picture can be tall and skinny
  const ADJUST_HEIGHT = (VW > 620);
  const POS_RESULT = getPrimaryDefPicturePosition();

  // TODO?
  //const MOBILE_ATTEMPT_PLACE_AROUND = false;
  // https://stackoverflow.com/questions/1248081/how-to-get-the-browser-viewport-dimensions
  //const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0)

  const imgClickClassName = "dh-right__img-container--clickable";
  const showEyeClassName = "dh-right__show-eye";
  const nsfwBlurInitClassName = "nsfw-blur-init";
  const nsfwBlurClassName = "nsfw-blur";
  const nsfwNoBlurClassName = "nsfw-no-blur";

  const EYE_PATH_RAW = "M12 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0 8a5 5 0 0 1-5-5 5 5 0 0 1 5-5 5 5 0 0 1 5 5 5 5 0 0 1-5 5m0-12.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5Z";
  const EYE_OFF_PATH_RAW = "M11.83 9 15 12.16V12a3 3 0 0 0-3-3h-.17m-4.3.8 1.55 1.55c-.05.21-.08.42-.08.65a3 3 0 0 0 3 3c.22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53a5 5 0 0 1-5-5c0-.79.2-1.53.53-2.2M2 4.27l2.28 2.28.45.45C3.08 8.3 1.78 10 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.43.42L19.73 22 21 20.73 3.27 3M12 7a5 5 0 0 1 5 5c0 .64-.13 1.26-.36 1.82l2.93 2.93c1.5-1.25 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-4 .7l2.17 2.15C10.74 7.13 11.35 7 12 7Z";

  const TOGGLE_STATE_INDEX_KEY = "jpmn-image-blur-state-index";

  const TOGGLE_STATE_DISABLED = -1;
  const TOGGLE_STATE_ALWAYS_SHOWN = 0;
  const TOGGLE_STATE_ONLY_BLUR_NSFW = 1;
  const TOGGLE_STATE_ALWAYS_BLURRED = 2;

  // card side state for image eye
  let imgCurrentlyBlurred = false;
  let toggleStates = [];

  // main image, global variable
  let image = null;


  // gets the function to activate the modal with the img
  const getActivateModalFunc = function(image) {
    return function() {
      modal.style.display = "block";
      modalImg.src = image.src;
    }
  }

  // sets the image to be blurred
  const setImgBlur = function(init=false) {
    logger.debug("Setting image blur...", 2)

    dhImgContainer.classList.toggle(imgClickClassName, false);
    dhImgBlur.classList.toggle(nsfwNoBlurClassName, false);

    if (init) {
      dhImgBlur.classList.toggle(nsfwBlurInitClassName, true);
    } else {
      dhImgBlur.classList.toggle(nsfwBlurClassName, true);
    }

    if (image !== null) {
      image.onclick = null;
    }
    imgEyePathEle.setAttributeNS(null, "d", EYE_OFF_PATH_RAW);

    imgCurrentlyBlurred = true;
  }

  // doesn't require the image to be currently blurred for this function to be ran
  const removeImgBlur = function() {
    logger.debug("Removing image blur...", 2)

    dhImgContainer.classList.add(imgClickClassName);

    dhImgBlur.classList.toggle(nsfwBlurClassName, false);
    dhImgBlur.classList.toggle(nsfwBlurInitClassName, false);
    dhImgBlur.classList.add(nsfwNoBlurClassName);

    if (image !== null) {
      const activateModalFunc = getActivateModalFunc(image);
      image.onclick = activateModalFunc;
    }
    imgEyePathEle.setAttributeNS(null, "d", EYE_PATH_RAW);

    imgCurrentlyBlurred = false;
  }

  // sets display state of settings eye
  function setDisplayState(state, settingsEye, displayPopup=true) {
    let settingsEyePathEle = settingsEye.children[0];
    let settingsEyeTitleEle = settingsEye.children[1];
    const alwaysBlurredClass = "info-circle-text-settings__svg--red";
    const settingsDisabledClass = "info-circle-text-settings__svg--disabled";

    switch (state) {
      case TOGGLE_STATE_DISABLED:
        settingsEyeTitleEle.textContent = "Persistence is not available. This option cannot be set.";
        settingsEyePathEle.classList.add(settingsDisabledClass);

        if (getShouldBlurNSFWDefault()) {
          settingsEyePathEle.setAttributeNS(null, "d", EYE_OFF_PATH_RAW);
        } else {
          settingsEyePathEle.setAttributeNS(null, "d", EYE_PATH_RAW);
        }
        break;

      case TOGGLE_STATE_ALWAYS_SHOWN:
        // never blurs
        settingsEyePathEle.setAttributeNS(null, "d", EYE_PATH_RAW);
        settingsEyeTitleEle.textContent = "NSFW images are not blurred by default. Click to toggle.";

        settingsEyePathEle.classList.toggle(alwaysBlurredClass, false);

        if (displayPopup) {
          popupMenuMessage("No images will be blurred.");
        }
        break;

      case TOGGLE_STATE_ONLY_BLUR_NSFW:
        // should blur on nsfw images
        settingsEyePathEle.setAttributeNS(null, "d", EYE_OFF_PATH_RAW);
        settingsEyeTitleEle.textContent = "NSFW images are blurred by default. Click to toggle.";
        settingsEyePathEle.classList.toggle(alwaysBlurredClass, false);

        if (displayPopup) {
          popupMenuMessage("NSFW images will be blurred.");
        }
        break;

      case TOGGLE_STATE_ALWAYS_BLURRED:
        // always blurs on nsfw images
        settingsEyePathEle.setAttributeNS(null, "d", EYE_OFF_PATH_RAW);
        settingsEyePathEle.classList.add(alwaysBlurredClass);
        settingsEyeTitleEle.textContent = "All images are blurred. Click to toggle.";

        if (displayPopup) {
          popupMenuMessage("All images will be blurred.");
        }
        break;
    }
  }

  function setImageBlurToState(toggleState, init=false) {
    if (imgEye == null) {
      return;
    }

    logger.debug(`Setting blur state to '${toggleState}' ...`, 2);
    switch (toggleState) {
      case 0: // ??? -> never blurred
        removeImgBlur();
        if (!cardHasNSFWTag()) {
          // removes if necessary (non-nsfw image forced to be blurred -> no longer forced)
          dhImgBlur.classList.toggle(showEyeClassName, false);
        }
        break;

      case 1: // ??? -> blur only if nsfw
        if (!cardHasNSFWTag()) {

          // can reach here on init as well
          removeImgBlur();

        } else if (!imgCurrentlyBlurred && cardHasNSFWTag()) {
          setImgBlur(init);
        }

        break;

      case 2: // ??? -> always blurred
        setImgBlur(init);
        if (!cardHasNSFWTag()) {
          dhImgBlur.classList.toggle(showEyeClassName, true);
        }
        break;

      default:
        logger.warning(`Invalid NSFW state: ${toggleState}`);
    }
  }


  function initPersistence() {
    let settingsEye = generateEyeSettingSVG();

    if (!getSetting(['modules','img-utils','image-blur','enabled',],false)) {
      // persistence only needs to be initialized if nsfw toggle is enabled
      return;
    } else {
      logger.debug("NSFW toggle enabled");
    }

    // inits persistence key
    const infoCircleSettings = document.getElementById("info_circle_text_settings");

    if (Persistence.isAvailable()) {
      if (Persistence.getItem(TOGGLE_STATE_INDEX_KEY) === null) {
        logger.debug(`First review, setting Persistence to ${0}`);
        Persistence.setItem(TOGGLE_STATE_INDEX_KEY, 0);
      } else {
        logger.debug("Persistence is available. Not the first review, so nothing has to be done.");
      }
    } else {
      logger.debug("Persistence is not available! Unable to init Persistence");
    }

    // visual interface for whether images should be blurred or not
    infoCircleSettings.appendChild(settingsEye);

    if (Persistence.isAvailable()) {

      // allows the usage of the global option
      settingsEye.onclick = function() {
        setNextNSFWToggleState();
        let toggleState = getCurrentNSFWToggleState();
        setImageBlurToState(toggleState)
        setDisplayState(toggleState, settingsEye);
      }

      // to display properly on the settings eye
      logger.debug(`Setting NSFW toggle state to '${getCurrentNSFWToggleState()}'...`);
      setDisplayState(getCurrentNSFWToggleState(), settingsEye, false);

    } else {
      setDisplayState(TOGGLE_STATE_DISABLED, settingsEye, false);
    }
  }


  // creates a custom image container to hold yomichan images
  function createImgContainer(imgName, shouldBlur) {
    // creating this programmically:
    // <span class="glossary__image-container">
    //   <a class="glossary__image-hover-text" href='javascript:;'</a>
    //   <img class="glossary__image-hover-media" src="${imgName}">
    // </span>

    const defSpan = document.createElement('span');
    defSpan.classList.add("glossary__image-container");

    const defAnc = document.createElement('a');
    defAnc.classList.add("glossary__image-hover-text");
    defAnc.href = "javascript:;";
    defAnc.textContent = "[Image]";
    defAnc.setAttribute("data-suppress-link-hover", "true");

    const defImg = document.createElement('img');
    defImg.classList.add("glossary__image-hover-media");
    defImg.src = imgName;

    defImg.onclick = function() {
      modal.style.display = "block";
      modalImg.src = this.src;
    }

    // prevents clicking on the image link to zoom (on mobile)
    if (!isMobile()) {
      defAnc.onclick = function() {
        modal.style.display = "block";
        modalImg.src = defImg.src;
      }
    }

    defSpan.appendChild(defAnc);
    defSpan.appendChild(defImg);

    return defSpan;
  }

  function generateEyeSettingSVG() {
    // a bit of a hacky way to do it without dealing with a bunch of raw js
    const svgStr = '<svg id="settings_nsfw_toggle_eye" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0 8a5 5 0 0 1-5-5 5 5 0 0 1 5-5 5 5 0 0 1 5 5 5 5 0 0 1-5 5m0-12.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5Z"/><title>Toggle blur</title></svg>';

    const x = document.createElement("span");
    x.innerHTML = svgStr;
    return x.children[0];
  }

  function useNSFWToggle() {

    imgEye.onclick = function() {
      if (imgCurrentlyBlurred) { // should be blurred -> not blurred
        removeImgBlur();
      } else { // not blurred -> should be blurred
        setImgBlur();
      }
    }

    const imgIsNsfw = cardHasNSFWTag();
    const shouldBlurImgDefault = getShouldBlurNSFWDefault();
    logger.debug(`imgIsNsfw: ${imgIsNsfw}, shouldBlurImgDefault: ${shouldBlurImgDefault}`);

    if (imgIsNsfw) {
      dhImgBlur.classList.toggle(showEyeClassName, true);
    }

    let toggleState = getCurrentNSFWToggleState();
    setImageBlurToState(toggleState, /*init=*/true);
  }


  function useModalAndBlur() {

    if (getSetting(['modules','img-utils','image-blur','enabled',],false)) {
      useNSFWToggle();
    } else {
      image.onclick = getActivateModalFunc(image);
    }
  }

  function setToggleStatesIfEmpty() {
    // toggleStates is module-global
    // TODO change this option to use the {"type": "pc-mobile"}
    if (toggleStates.length === 0) {
      toggleStates = getSetting(['modules','img-utils','image-blur','toggle-states',],{"type": "pc-mobile", "pc": [1, 2, 0], "mobile": [1, 2, 0]});
    }
  }

  function getDefaultNSFWToggleState() {
    setToggleStatesIfEmpty();
    return toggleStates[0];
  }

  function getCurrentNSFWToggleState() {
    setToggleStatesIfEmpty();
    if (Persistence.isAvailable()) {
      const currentStateIndex = Persistence.getItem(TOGGLE_STATE_INDEX_KEY);
      const currentState = toggleStates[currentStateIndex]
      logger.debug(`Persistence[${currentStateIndex}] returns ${currentState}`, 1);
      return currentState;
    }
    logger.debug("Persistence not available! Falling back to default value...", 2);
    return toggleStates[0];
  }

  function setNextNSFWToggleState() {
    setToggleStatesIfEmpty();

    let currentStateIndex = Persistence.getItem(TOGGLE_STATE_INDEX_KEY);
    let nextStateIndex = (currentStateIndex + 1) % toggleStates.length;
    logger.debug(`Setting Persistence: ${nextStateIndex}`, 2)
    Persistence.setItem(TOGGLE_STATE_INDEX_KEY, nextStateIndex);

    return toggleStates[nextStateIndex];
  }


  function getShouldBlurNSFWDefault() {
    return (getDefaultNSFWToggleState() >= 1);
  }

  //function getTags() {
  //  return document.getElementById("tags").innerText.split(" ");
  //}

  // checks if A is a subset of B
  // in other words, if any item in A is in B
  function checkArrayIsSubset(A, B) {
    for (item of A) {
      if (B.includes(item)) {
        return true;
      }
    }
    return false;
  }

  function cardHasNSFWTag() {
    //const tags = getTags();
    const nsfwTags = getSetting(['modules','img-utils','image-blur','tags',],['NSFW', 'nsfw', '-NSFW']);

    return checkArrayIsSubset(nsfwTags, TAGS_LIST);
  }

  function cardContainsAllTags(tagList) {
    //const tags = document.getElementById("tags").innerText.split(" ");

    let count = 0;
    for (t of tagList) {
      if (TAGS_LIST.includes(t)) {
        count += 1;
      }
    }

    return (count === tagList.length);
  }

  function getPrimaryDefPicturePosition() {
    let posResult = "auto";

    const posOpt = getSetting(['modules','img-utils','primary-definition-picture','position',],'auto');
    const tagsBottom = getSetting(['modules','img-utils','primary-definition-picture','tags-bottom',],['img-bottom', 'jpmn-img-buttom']);
    const tagsRight = getSetting(['modules','img-utils','primary-definition-picture','tags-right',],['img-right', 'jpmn-img-right']);

    if (checkArrayIsSubset(tagsBottom, TAGS_LIST)) { // priority on tag
      posResult = "bottom";
    } else if (checkArrayIsSubset(tagsRight, TAGS_LIST)) {
      posResult = "right";
    } else if (posOpt === "bottom") { // lower priority on posOpt
      posResult = "bottom";
    } else if (posOpt === "right") {
      posResult = "right";
    } else if (posOpt === "auto") {
      posResult = "auto";
    } else {
      logger.warn(`Invalid option value for 'primary-definition-picture-position': ${posOpt}. Defaulting to auto.`);
      posResult = "auto";
    }

    return posResult;

  }


  function editDisplayImage() {
    // edits the display image width/height
    // makes the display image clickable to zoom
    // makes the modal clickable to un-zoom

    // restricting the max height of image to the definition box
    // TODO this one line of code seems to reflow the document, causing noticeable delay in the js
    // https://stackoverflow.com/questions/45960181/what-is-the-fastest-way-to-get-height-width-of-unstyled-element-in-javascript
    // https://stackoverflow.com/questions/19815810/avoiding-html-document-reflows/19816067#19816067

    // this appears to be the main bottleneck in performance for some awful reason
    // and it seems virtually impossible to remove it...
    // the best I can do is group all the calls together so only the first .offsetHeight read
    // slows the program down.
    // This code also CANNOT be placed at the top where global variables are defined,
    // because the height is dependent on the height of the resulting pitch accent.
    // Even if the code could be placed at the top, it still seems to cause a reflow,
    // so nothing has changed...


    if (ADJUST_HEIGHT || POS_RESULT === "auto") {
      HEIGHT_LEFT = dhLeft === null ? 0 : dhLeft.offsetHeight;
      TEXT_HEIGHT = primaryDefText === null ? 0 : primaryDefText.offsetHeight;
      PIC_HEIGHT = primaryDefPicEle === null ? 0 : primaryDefPicEle.offsetHeight;
      FLOAT_PIC_HEIGHT = primaryDefExtLinks === null ? 0 : primaryDefExtLinks.offsetHeight;
    }


    let somethingDisplayed = dhImgContainer.innerHTML.length > 0;

    // attempts to add image according to the tag
    const addTagsInfo = getSetting(['modules','img-utils','add-image-if-contains-tags',],[]);
    if (!somethingDisplayed && addTagsInfo) {
      for (const info of addTagsInfo) {
        const tags = info["tags"];
        const fileName = info["file-name"];

        if (cardContainsAllTags(tags)) {
          const newImg = document.createElement('img');
          newImg.src = fileName;
          dhImgContainer.appendChild(newImg);
          dhRight.classList.add("dh-right--contains-image");
          dhLeftAudioBtns.classList.add("dh-left__audio-buttons--left");
          somethingDisplayed = true;

          break;
        }
      }
    }

    if (somethingDisplayed) {
      if (ADJUST_HEIGHT) {
        dhRight.style.maxHeight = HEIGHT_LEFT + "px";
      }

      // setting up the modal styles and clicking
      const imgList = dhImgContainer.getElementsByTagName("img");

      if (imgList && imgList.length) {
        if (imgList.length >= 2) {
          logger.warn("There are more than 2 images?");
        }

        // module-global variable
        image = imgList[0];

        image.classList.add("dh-right__img");
        if (ADJUST_HEIGHT) {
          image.style.maxHeight = HEIGHT_LEFT + "px"; // restricts max height here too
        }

        useModalAndBlur();

      } else { // otherwise we hope that there are 0 images here
        // support for no images here: remove the fade-in / fade-out on text
        logger.debug("No images found. Removing clickable class...");
        dhImgContainer.classList.remove(imgClickClassName);
      }
    }

    // close the modal upon click
    modal.onclick = function() {
      bigimg.classList.add("modal-img__zoom-out");
      modal.classList.add("modal-img__zoom-out");
      setTimeout(function() {
        modal.style.display = "none";
        bigimg.className = "modal-img";
        modal.className = "modal";
      }, 200);
    }

  }

  function searchImages() {

    // goes through each blockquote and searches for yomichan inserted images
    //const imageSearchElements = document.getElementsByTagName("blockquote");
    const imageSearchElements = document.querySelectorAll("blockquote.glossary-blockquote .glossary-text");
    for (const searchEle of imageSearchElements) {
      const anchorTags = searchEle.getElementsByTagName("a");
      for (const atag of anchorTags) {
        const imgFileName = atag.getAttribute("href");
        if (imgFileName && imgFileName.substring(0, 25) === "yomichan_dictionary_media") {
          logger.debug(`Converting yomichan image ${imgFileName}...`);
          const fragment = createImgContainer(imgFileName);
          atag.parentNode.replaceChild(fragment, atag);
        }
      }

      // looks for user inserted images
      const imgTags = searchEle.getElementsByTagName("img");
      for (const imgEle of imgTags) {
        if (!imgEle.classList.contains("glossary__image-hover-media") &&
            !(imgEle.getAttribute("data-do-not-convert"))
        ) { // created by us
          logger.debug(`Converting user-inserted image ${imgEle.src}...`);
          const shouldBlur = !!imgEle.getAttribute("data-blur-image"); // double ! casts to bool
          const fragment = createImgContainer(imgEle.src, shouldBlur);
          imgEle.parentNode.replaceChild(fragment, imgEle);
        }
      }
    }


    // looks for the PrimaryDefinitionPicture if it exists
    // placed after image searches to allow main definition to be properly resized first
    const primaryDefPicEle = document.getElementById("primary_definition_picture")
    const primaryDefPicBottomEle = document.getElementById("primary_definition_picture_bottom")
    for (const picEle of [primaryDefPicEle, primaryDefPicBottomEle]) {
      if (picEle === null) {
        continue;
      }
      const imgs = picEle.getElementsByTagName("img");
      for (const imgEle of imgs) {
        if (imgEle !== null) {
          imgEle.onclick = getActivateModalFunc(imgEle);
          imgEle.classList.add(imgClickClassName);
        }
      }
    }

    //const tags = getTags();
    const primaryDefBlockquote = document.getElementById("primary_definition");

    let posResult = POS_RESULT;

    if (posResult === "auto") {
      // compares height of definition text and image
      //const primaryDefExtLinks = document.getElementById("external_links_primary_def_float");
      //const primaryDefText = document.getElementById("primary_definition_text");
      const lenience = getSetting(['modules','img-utils','primary-definition-picture','position-lenience',],2);

      const textHeight = TEXT_HEIGHT * lenience;
      const picHeight = PIC_HEIGHT + FLOAT_PIC_HEIGHT;
      const shouldFloat = textHeight > picHeight;
      logger.debug(`shouldFloat=${shouldFloat}, textHeight=${textHeight}, picHeight=${picHeight}`);

      posResult = shouldFloat ? "right" : "bottom";
    }
    logger.debug(`PrimaryDefinitionPicture position: ${posResult}`);

    // nothing has to be done for "right" as that is the default
    if (posResult === "bottom") {
      primaryDefBlockquote.classList.add("glossary-blockquote--picture-below");
    }


  }

  class JPMNImgUtils {
    constructor() {
      initPersistence()
    }

    run() {
      editDisplayImage();

      if (getSetting(['modules','img-utils','stylize-images-in-glossary',],true)) {
        searchImages();
      }
    }
  }


  return JPMNImgUtils;

})();



/// 



















// ===================
//  Info Circle Utils
// ===================

const JPMNInfoCircleUtils = (() => {

  const logger = new JPMNLogger("info-circle-utils");

  // private functions and variables here
  // ...

  class JPMNInfoCircleUtils {
    constructor() { }

    run() {

      let infoCirc = document.getElementById("info_circle");
      let infoCircWrapper = document.getElementById("info_circle_wrapper");

      // clicks on the info circle to freeze the popup (good for debugging and all)
      if (getSetting(['modules','info-circle-utils','togglable-lock','enabled',],true)) {

        const showPopup = getSetting(['modules','info-circle-utils','togglable-lock','show-popup',],{"type": "pc-mobile", "pc": true, "mobile": false});

        //function addLockFunc(clickEle, circEle, displayName, frozenClassName, togglableClassName, showPopup) {
        //  if (clickEle === null || circEle === null) {
        //    return;
        //  }

        //  clickEle.classList.add(togglableClassName);
        //  clickEle.onclick = function() {
        //    if (circEle.classList.contains(frozenClassName)) {
        //      circEle.classList.remove(frozenClassName);
        //      if (showPopup) {
        //        popupMenuMessage(`${displayName} unlocked.`, true);
        //      }
        //    } else {
        //      circEle.classList.add(frozenClassName);
        //      if (showPopup) {
        //        popupMenuMessage(`${displayName} locked.`, true);
        //      }
        //    }
        //  }

        //}

        // main info circle
        const infoCircFrozen = "info-circle--frozen";
        const infoCircTogglable = "info-circle-svg-wrapper--togglable";
        //addLockFunc(infoCircWrapper, infoCirc, "Info circle tooltip", infoCircFrozen, infoCircTogglable, showPopup);

        //if (infoCircWrapper === null || infoCirc === null) {
        //  return;
        //}

        if (!isMobile()) {
          infoCircWrapper.classList.toggle(infoCircTogglable, true);
        }

        infoCircWrapper.onclick = function() {
          if (infoCirc.classList.contains(infoCircFrozen)) {
            infoCirc.classList.remove(infoCircFrozen);
            if (showPopup) {
              popupMenuMessage(`Info circle tooltip unlocked.`, true);
            }
          } else {
            infoCirc.classList.add(infoCircFrozen);
            if (showPopup) {
              popupMenuMessage(`Info circle tooltip locked.`, true);
            }
          }
        }
      }

      if (!getSetting(['modules','info-circle-utils','is-hoverable',],{"type": "pc-mobile", "pc": true, "mobile": false})) {
        infoCircWrapper.classList.toggle("info-circle-svg-wrapper--hoverable", false);
        infoCirc.classList.toggle("info-circle--hover-color", false);
      }

    }
  }


  return JPMNInfoCircleUtils;

})();

/// 




















// a general function to implement all keybinds necessary by the card.
// NOTICE: we MUST use document.onkeyup instead of document.addEventListener(...)
// because functions persist and cannot be easily removed within anki,
// whereas .onkeyup = ... replaces the previous function with the current.
document.onkeyup = (e => {
  LOGGER.debug(`KeyboardEvent: code=${e.code}`, 0);

  let keys = null;
  let ele = null;

  // START_BLOCK: js_keybind_settings




  // END_BLOCK: js_keybind_settings



























  /// {{#WordAudio}}
  keys = getSetting(['keybinds','play-word-audio',],['KeyW']);

  if (keys !== null && keys.includes(e.code)) {
    ele = document.querySelector("#word-audio .soundLink, #word-audio .replaybutton");
    if (ele) {
      ele.click();
    }
  }
  /// {{/WordAudio}}

  /// {{#SentenceAudio}}
  keys = getSetting(['keybinds','play-sentence-audio',],['KeyP']);
  if (keys !== null && keys.includes(e.code)) {

    let hSent = document.getElementById("hybrid-sentence");

    /// 
      ele = document.querySelector("#sentence-audio .soundLink, #sentence-audio .replaybutton");
      if (ele) {
        ele.click();
      }
    /// 
  }
  /// {{/SentenceAudio}}

  keys = getSetting(['keybinds','toggle-front-full-sentence-display',],['Quote']);
  ele = document.getElementById("full_sentence_front_details");
  if (keys !== null && ele && keys.includes(e.code)) {
    toggleDetailsTag(ele)
  }

  /// {{#Hint}}
  keys = getSetting(['keybinds','toggle-hint-display',],['Period']);
  ele = document.getElementById("hint_details");
  if (keys !== null && ele && keys.includes(e.code)) {
    toggleDetailsTag(ele)
  }
  /// {{/Hint}}

  ///  

})
///  





function main() {
  

  


  // sanity check: options
  /// 
  if (typeof JPMNOpts === 'undefined') {
    LOGGER.warn('JPMNOpts was not defined in the options file. Was there an error? ' +
      'Click <a href="https://aquafina-water-bottle.github.io/jp-mining-note/faq/#warning-jpmnopts-was-not-defined-in-the-options-file-was-there-an-error">here</a> for basic troubleshooting.', isHtml=true);
  }
  ///  

  // sanity check: checks that both `IsHoverCard` and `IsClickCard` are both not activated
  /// {{#IsHoverCard}}
  /// {{#IsClickCard}}
  LOGGER.warn("Both `IsHoverCard` and `IsClickCard` are filled. At most one should be filled at once.");
  /// {{/IsClickCard}}
  /// {{/IsHoverCard}}


  // Stylizes the play button for ankidroid
  if (isMobile()) {
    const betterPlayBtn = `<svg class="android-play-button-svg" viewBox="0 0 64 64" version="1.1"> <circle cx="32" cy="32" r="29"></circle> <path d="M56.502,32.301l-37.502,20.101l0.329,-40.804l37.173,20.703Z"></path> </svg>`

    function generateSVG() {
      const x = document.createElement("span");
      x.innerHTML = betterPlayBtn;
      return x.children[0];
    }

    const eles = document.querySelectorAll(".android .replaybutton svg");
    for (const ele of eles) {
      ele.parentNode.replaceChild(generateSVG(), ele);
    }
  }


  // START_BLOCK: js_run




  // END_BLOCK: js_run

  





  try { // RUN: sent-utils

    

    
        
    if (getSetting(['modules','sent-utils','enabled',],true)) {
      let isAltDisplay = false;
      /* {{#AltDisplayPASentenceCard}} */
        isAltDisplay = true;
      /* {{/AltDisplayPASentenceCard}} */

      /* {{^AltDisplayPASentenceCard}} */
        /* {{#AltDisplay}} */
        isAltDisplay = (
          /* {{^IsClickCard}}{{^IsHoverCard}}{{^IsSentenceCard}}{{^IsTargetedSentenceCard}} */
            false &&
          /* {{/IsTargetedSentenceCard}}{{/IsSentenceCard}}{{/IsHoverCard}}{{/IsClickCard}} */
          true ? true : false
        );
        /* {{/AltDisplay}} */

        /* {{^AltDisplay}} */
          isAltDisplay = false;
        /* {{/AltDisplay}} */
      /* {{/AltDisplayPASentenceCard}} */

      let sent_utils = new JPMNSentUtils(isAltDisplay);
      sent_utils.run();

    }
    /// 
        

    

  } catch (error) {
    LOGGER.error("Error in module sent-utils:");
    LOGGER.errorStack(error.stack);
  }














  try { // RUN: img-utils

    

    
        

    if (getSetting(['modules','img-utils','enabled',],true) && getSetting(['modules','img-utils','image-blur','enabled',],false)) {
      // ran just to call constructor
      const imgUtils = new JPMNImgUtils();
    }

    /// 
        

    

  } catch (error) {
    LOGGER.error("Error in module img-utils:");
    LOGGER.errorStack(error.stack);
  }








  try { // RUN: info-circle-utils

    

    
        

    if (getSetting(['modules','info-circle-utils','enabled',],true)) {
      const infoCircleUtils = new JPMNInfoCircleUtils()
      infoCircleUtils.run();
    }

    /// 
        

    

  } catch (error) {
    LOGGER.error("Error in module info-circle-utils:");
    LOGGER.errorStack(error.stack);
  }




  try { // RUN: fix-ruby-positioning

    

    
        

    if (getSetting(['modules','fix-ruby-positioning','enabled',],{"type": "pc-mobile", "pc": false, "mobile": false})) {
      // module not big enough to require a class

      const className = "fix-ruby-positioning";
      const defHeader = document.getElementById("def_header");
      if (defHeader !== null) {
        defHeader.classList.add(className);
      }

      const expressions = document.querySelectorAll(".expression");
      if (expressions !== null) {
        for (const e of expressions) {
          e.classList.add(className);
        }
      }

    }

    /// 
        

    

  } catch (error) {
    LOGGER.error("Error in module fix-ruby-positioning:");
    LOGGER.errorStack(error.stack);
  }






  

}





main();



}());

</script>




{{/SentenceAudio}}
{{/PASeparateSentenceCard}}
