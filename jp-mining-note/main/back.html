
<!--
WARNING: This template is auto-generated.
Any changes to this template WILL BE LOST if you decide to update the card.

JPMN-COMPILE-TIME-OPTIONS-JSON:
{
  "available-modules": {
    "auto-pitch-accent": true,
    "img-utils": true,
    "kanji-hover": true,
    "open_on_new": true,
    "sent-utils": true
  },
  "available-themes": [],
  "compile-options": {
    "always-filled-fields": [],
    "enabled-modules": [
      "img-utils",
      "sent-utils",
      "kanji-hover",
      "auto-pitch-accent",
      "open_on_new"
    ],
    "never-filled-fields": []
  }
}

-->



{{#FrequenciesStylized}}
  {{FrequenciesStylized}}
{{/FrequenciesStylized}}


<script>


/* quick fix for legacy anki versions (replaces ?? operator) */
function nullish(a, b) {
  if ((typeof a === "undefined") || (a === null)) {
    return b;
  }
  return a;
}



function getSetting(keys, defaultVal) {
  if (typeof JPMNOpts === "undefined") {
    return defaultVal;
  }

  let keyList = ["settings"].concat(keys);

  let obj = JPMNOpts;
  for (let key of keyList) {
    if (!(key in obj)) {

      // checks if we need to warn, manual search
      if ("settings" in JPMNOpts && "debug" in JPMNOpts["settings"] && JPMNOpts["settings"]["debug"]) {
        LOGGER.warn("Option " + keys.join(".") + " is not defined in the options file.");
      }
      return defaultVal;
    }
    obj = obj[key];
  }
  return obj;
};


var JPMNLogger = (() => {
  class JPMNLogger {
    constructor(name=null) {
      this._name = name;
      this._uniqueKeys = new Set();
    }


    error(message) {
      let groupEle = document.getElementById("info_circle_text_error");
      this._appendMsg(message, groupEle);
      let infoCirc = document.getElementById("info_circle");
      if (!infoCirc.classList.contains("info-circle-error")) {
        infoCirc.classList.add("info-circle-error")
      }
    }

    errorStack(stack) {
      let stackList = stack.split(" at ");
      for (let i = 1; i < stackList.length; i++) {
        stackList[i] = ">>> " + stackList[i];
      }
      this.error(stackList);
    }


    assert(condition, message) {
      if (!condition) {
        this.error("(assert) " + message);
      }
    }

    removeWarn(key) {
      // assumes that this is a unique warn message

      if (!this._uniqueKeys.has(key)) {
        return;
      }

      let groupEle = document.getElementById("info_circle_text_warning");
      for (let e of groupEle.children) {
        if (e.getAttribute("data-key") === key) {
          groupEle.removeChild(e);
        }
      }

      let infoCirc = document.getElementById("info_circle");
      if (groupEle.children.length === 0 && infoCirc.classList.contains("info-circle-warning")) {
        infoCirc.classList.remove("info-circle-warning")
      }

      this._uniqueKeys.delete(key);
    }

    // key defaults to the message if unique is true and key is null
    // key is ignored if unique == false
    warn(message, unique=true, key=null) {

      // skips any non-unique warns as defined by the key
      if (unique) {
        if (key === null) {
          key = message;
        }

        if (this._uniqueKeys.has(key)) {
          return;
        }
      }

      let groupEle = document.getElementById("info_circle_text_warning");
      this._appendMsg(message, groupEle, key);
      let infoCirc = document.getElementById("info_circle");
      if (!infoCirc.classList.contains("info-circle-warning")) {
        infoCirc.classList.add("info-circle-warning")
      }

      if (key !== null) {
        this._uniqueKeys.add(key);
      }

    }

    info(message) {
      let groupEle = document.getElementById("info_circle_text_info");
      this._appendMsg(message, groupEle);
    }

    debug(message) {
      if (getSetting(['debug',],false)) {
        this.info(message);
      }
    }

    leech() {
      let groupEle = document.getElementById("info_circle_text_leech");
      this._appendMsg("", groupEle);
      let infoCirc = document.getElementById("info_circle");
      if (!infoCirc.classList.contains("info-circle-leech")) {
        infoCirc.classList.add("info-circle-leech")
      }
    }

    _appendMsg(message, groupEle, key=null) {
      // I think this stops an infinite loop somewhere if you log a null for some reason...
      if (message === null) {
        message = "null";
      }

      if (this._name !== null) {
        message = `(${this._name}) ${message}`
      }

      let msgEle = document.createElement('div');
      msgEle.classList.add("info-circle__message")
      if (key !== null) {
        msgEle.setAttribute("data-key", key);
      }

      if (Array.isArray(message)) {
        if (message.length > 0) {
          msgEle.textContent = message[0];

          for (let line of message.slice(1)) {
            let lineEle = document.createElement('div');
            lineEle.textContent = line;
            msgEle.appendChild(lineEle);
          }
        }

      } else {
        msgEle.textContent = message;
      }
      groupEle.appendChild(msgEle);
    }

  }

  return JPMNLogger;
})();



/* global logger object for any javascript outside of modules that needs logging */
var LOGGER = nullish(LOGGER, new JPMNLogger());

/* TEMPORARY logger for legacy code to work */
//var logger = nullish(logger, new JPMNLogger("DEPRECATED"));


// on any javascript error: log it
window.onerror = function(msg, url, lineNo, columnNo, error) {
  LOGGER.errorStack(error.stack);
}

// https://stackoverflow.com/a/55178672
window.onunhandledrejection = function(errorEvent) {
  LOGGER.error("Javascript handler error: `" + errorEvent.reason + "`");
}


function optionsNotFound() {
  LOGGER.warn("Options file not found. Did you place the options file in the media directory?");
}



</script>

<script onerror="optionsNotFound();" src="_jpmn-options.js"></script>


<!-- hidden fields
     used instead of inserting a template directly into javascript code
     in order to prevent escaping errors (e.g. if the field contains a `"`)
-->
<div class="hidden">
  <div id="hidden_pa_positions">{{PAPositions}}</div>
  <div id="hidden_word_reading">{{WordReading}}</div>
  <div id="hidden_ajt_word_pitch">{{AJTWordPitch}}</div>
  <div id="hidden_pa_override">{{PAOverride}}</div>
  <div id="tags">{{Tags}}</div>
</div>



<div class="card-description">
  

    

    


  {{#IsHoverCard}}
    Hover ({{#IsSentenceCard}}Sentence{{/IsSentenceCard}}{{^IsSentenceCard}}Word{{/IsSentenceCard}})
  {{/IsHoverCard}}


  {{^IsHoverCard}}

    {{#IsClickCard}}
      Click ({{#IsSentenceCard}}Sentence{{/IsSentenceCard}}{{^IsSentenceCard}}Word{{/IsSentenceCard}})
    {{/IsClickCard}}

    {{^IsClickCard}}
      {{#IsTargetedSentenceCard}}
        TSC
      {{/IsTargetedSentenceCard}}
      {{^IsTargetedSentenceCard}}
        {{#IsSentenceCard}}
          Sentence
        {{/IsSentenceCard}}
        {{^IsSentenceCard}}
          Word
        {{/IsSentenceCard}}
      {{/IsTargetedSentenceCard}}  
    {{/IsClickCard}}  
  {{/IsHoverCard}} 

  {{#PAShowInfo}}

    /

    <!-- PADoNotTest or PASeparateWordCard == none -->
    {{#PADoNotTest}}{{^PASeparateWordCard}}
      None
    {{/PASeparateWordCard}}{{/PADoNotTest}}{{^PADoNotTest}}{{#PASeparateWordCard}}
      None
    {{/PASeparateWordCard}}{{/PADoNotTest}}{{#PADoNotTest}}{{#PASeparateWordCard}}
      None
    {{/PASeparateWordCard}}{{/PADoNotTest}}
    



    <!-- neither PADoNotTest, PASeparateWordCard are filled -->
    <!-- we then test the PA somewhere -->
    {{^PADoNotTest}}{{^PASeparateWordCard}}

      <!-- PASeparateSentenceCard or PATestOnlyWord == word -->
      {{#PASeparateSentenceCard}}{{^PATestOnlyWord}}
        Word
      {{/PATestOnlyWord}}{{/PASeparateSentenceCard}}{{^PASeparateSentenceCard}}{{#PATestOnlyWord}}
        Word
      {{/PATestOnlyWord}}{{/PASeparateSentenceCard}}{{#PASeparateSentenceCard}}{{#PATestOnlyWord}}
        Word
      {{/PATestOnlyWord}}{{/PASeparateSentenceCard}}
    



      <!-- if none of the above, then we test the default value -->
      {{^PASeparateSentenceCard}}{{^PATestOnlyWord}}

        <!-- note: default for TSC is test word, may change in the future... -->
        {{#IsSentenceCard}}
          Sentence
        {{/IsSentenceCard}}
        {{^IsSentenceCard}}
          Word
        {{/IsSentenceCard}}

      {{/PATestOnlyWord}}{{/PASeparateSentenceCard}}

    {{/PASeparateWordCard}}{{/PADoNotTest}}

  {{/PAShowInfo}} 




    
  <span class="info-circle" id="info_circle">
    <span class="info-circle-svg-wrapper">
      <svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" class="bi bi-info-circle" viewBox="0 0 16 16">
        <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
        <path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
      </svg>
    </span>

    <span class="info-circle-text-wrapper">
      <span class="info-circle-text" id="info_circle_text">
        <div class="info-circle-text-error" id="info_circle_text_error"></div>
        <div class="info-circle-text-warning" id="info_circle_text_warning"></div>
        <div class="info-circle-text-leech" id="info_circle_text_leech"></div>
        <div class="info-circle-text-info" id="info_circle_text_info">
          <div>
            Need help? View the
            <a href="https://aquafina-water-bottle.github.io/jp-mining-note/">documentation</a>.
          </div>
          <div>
            Have an issue?
            <a href="https://github.com/Aquafina-water-bottle/jp-mining-note/issues">Report it here</a>.
          </div>
          <div>
            View the
            <a href="https://github.com/Aquafina-water-bottle/jp-mining-note">source code</a>.
          </div>
        </div>
      </span>
    </span>
  </span>


    
  <div class="card-description-ver">JP Mining Note: Version 0.10.1.0</div>


    
</div>







<!-- legacy display -->
{{^PAShowInfo}}

  <!-- priority is on the alternate display sentence -->

  {{#IsHoverCard}}
    <!-- fallback card card html
      in css: default hybrid css, but with hover instead of click -->
    <div class="expression__hybrid-wrapper">
      <div class="expression expression--single expression__hybrid expression__hybrid--hover" id="display">
        <span class="expression--sentence expression__hybrid-sentence expression
                   {{^IsSentenceCard}} bold-yellow {{/IsSentenceCard}}
                   {{#IsTargetedSentenceCard}} bold-yellow {{/IsTargetedSentenceCard}}
                   "
              id="hybrid-sentence">
          <span class="sentence-quote sentence-quote--open">「</span><span>{{#AltDisplay}}{{furigana:AltDisplay}}{{/AltDisplay}}{{^AltDisplay}}{{Sentence}}{{/AltDisplay}}</span><span class="sentence-quote sentence-quote--close">」</span>
        </span>
        <span class="expression--word expression__hybrid-word
            {{#IsTargetedSentenceCard}} expression__hybrid-word--sentence-underline {{/IsTargetedSentenceCard}}
            {{^IsTargetedSentenceCard}}
              {{#IsSentenceCard}} expression__hybrid-word--sentence-underline {{/IsSentenceCard}}
              {{^IsSentenceCard}} expression__hybrid-word--word-underline {{/IsSentenceCard}}
            {{/IsTargetedSentenceCard}}
            expression__hybrid-word--hover-indicator"
            id="hybrid-word">
          {{Word}}
        </span>
      </div>
    </div>
  {{/IsHoverCard}} 

  {{^IsHoverCard}}

    {{#IsClickCard}}
      <!-- hybrid (sentence or word) card html
        in css: default hybrid css, with click -->
      <div class="expression__hybrid-wrapper">
        <div class="expression expression--single expression__hybrid expression__hybrid--click" id="display">
          <span class="expression--sentence expression__hybrid-sentence
                    {{^IsSentenceCard}} bold-yellow {{/IsSentenceCard}}
                    {{#IsTargetedSentenceCard}} bold-yellow {{/IsTargetedSentenceCard}}
                    "
                id="hybrid-sentence">
            <span class="sentence-quote sentence-quote--open">「</span><span>{{#AltDisplay}}{{furigana:AltDisplay}}{{/AltDisplay}}{{^AltDisplay}}{{Sentence}}{{/AltDisplay}}</span><span class="sentence-quote sentence-quote--close">」</span>
          </span>
          <span class="expression--word expression__hybrid-word
                {{#IsTargetedSentenceCard}} expression__hybrid-word--sentence-underline {{/IsTargetedSentenceCard}}
                {{^IsTargetedSentenceCard}}
                  {{#IsSentenceCard}} expression__hybrid-word--sentence-underline {{/IsSentenceCard}}
                  {{^IsSentenceCard}} expression__hybrid-word--word-underline {{/IsSentenceCard}}
                {{/IsTargetedSentenceCard}}
              expression__hybrid-word--click-indicator"
              id="hybrid-word">
            {{Word}}
          </span>
        </div>
      </div>
    {{/IsClickCard}} 


    {{^IsClickCard}}

      {{#IsTargetedSentenceCard}}
        <div class="expression expression--sentence expression--single bold-yellow" id="display">
          <span class="sentence-quote sentence-quote--open">「</span><span>{{#AltDisplay}}{{furigana:AltDisplay}}{{/AltDisplay}}{{^AltDisplay}}{{Sentence}}{{/AltDisplay}}</span><span class="sentence-quote sentence-quote--close">」</span>
        </div>
      {{/IsTargetedSentenceCard}}

      {{^IsTargetedSentenceCard}}
        {{#IsSentenceCard}}
          <div class="expression expression--sentence expression--single" id="display">
            <span class="sentence-quote sentence-quote--open">「</span><span>{{#AltDisplay}}{{furigana:AltDisplay}}{{/AltDisplay}}{{^AltDisplay}}{{Sentence}}{{/AltDisplay}}</span><span class="sentence-quote sentence-quote--close">」</span>
          </div>
        {{/IsSentenceCard}}

        {{^IsSentenceCard}}
          <div class="expression expression--word expression--single" id="display">
            {{#AltDisplay}}{{furigana:AltDisplay}}{{/AltDisplay}}{{^AltDisplay}}{{Word}}{{/AltDisplay}}
          </div>
        {{/IsSentenceCard}}
      {{/IsTargetedSentenceCard}} 

    {{/IsClickCard}} 

  {{/IsHoverCard}} 

{{/PAShowInfo}} 


<!-- regular display -->
{{#PAShowInfo}}
  <div class="expression expression-box">

    <!-- priority is on the alternate display sentence -->


    {{#IsHoverCard}}
      <!-- fallback card card html
        in css: default hybrid css, but with hover instead of click -->
      <div class="expression__hybrid-wrapper">
        <div class="expression expression__hybrid expression__hybrid--hover" id="display">
          <span class="expression--sentence expression__hybrid-sentence
                       {{^IsSentenceCard}} bold-yellow {{/IsSentenceCard}}
                       {{#IsTargetedSentenceCard}} bold-yellow {{/IsTargetedSentenceCard}}
                       "
                id="hybrid-sentence">
            <span class="sentence-quote sentence-quote--open">「</span><span>{{#AltDisplay}}{{furigana:AltDisplay}}{{/AltDisplay}}{{^AltDisplay}}{{Sentence}}{{/AltDisplay}}</span><span class="sentence-quote sentence-quote--close">」</span>
          </span>
          <span class="expression--word expression__hybrid-word
              {{#IsTargetedSentenceCard}} expression__hybrid-word--sentence-underline {{/IsTargetedSentenceCard}}
              {{^IsTargetedSentenceCard}}
                {{#IsSentenceCard}} expression__hybrid-word--sentence-underline {{/IsSentenceCard}}
                {{^IsSentenceCard}} expression__hybrid-word--word-underline {{/IsSentenceCard}}
              {{/IsTargetedSentenceCard}}
              expression__hybrid-word--hover-indicator"
              id="hybrid-word">
            {{Word}}
          </span>
        </div>

      </div>

    {{/IsHoverCard}} 

    {{^IsHoverCard}}

      {{#IsClickCard}}
        <!-- hybrid (sentence or word) card html
          in css: default hybrid css, with click -->
        <div class="expression__hybrid-wrapper">
          <div class="expression expression__hybrid expression__hybrid--click" id="display">
            <span class="expression--sentence expression__hybrid-sentence
                      {{^IsSentenceCard}} bold-yellow {{/IsSentenceCard}}
                      {{#IsTargetedSentenceCard}} bold-yellow {{/IsTargetedSentenceCard}}
                      "
                  id="hybrid-sentence">
              <span class="sentence-quote sentence-quote--open">「</span><span>{{#AltDisplay}}{{furigana:AltDisplay}}{{/AltDisplay}}{{^AltDisplay}}{{Sentence}}{{/AltDisplay}}</span><span class="sentence-quote sentence-quote--close">」</span>
            </span>
            <span class="expression--word expression__hybrid-word
                {{#IsTargetedSentenceCard}} expression__hybrid-word--sentence-underline {{/IsTargetedSentenceCard}}
                {{^IsTargetedSentenceCard}}
                  {{#IsSentenceCard}} expression__hybrid-word--sentence-underline {{/IsSentenceCard}}
                  {{^IsSentenceCard}} expression__hybrid-word--word-underline {{/IsSentenceCard}}
                {{/IsTargetedSentenceCard}}
                expression__hybrid-word--click-indicator"
                id="hybrid-word">
              {{Word}}
            </span>
          </div>
        </div>
      {{/IsClickCard}} 

      {{^IsClickCard}}

        {{#IsTargetedSentenceCard}}
          <div class="expression expression--sentence bold-yellow" id="display">
            <span class="sentence-quote sentence-quote--open">「</span><span>{{#AltDisplay}}{{furigana:AltDisplay}}{{/AltDisplay}}{{^AltDisplay}}{{Sentence}}{{/AltDisplay}}</span><span class="sentence-quote sentence-quote--close">」</span>
          </div>
        {{/IsTargetedSentenceCard}}

        {{^IsTargetedSentenceCard}}
          {{#IsSentenceCard}}
            <div class="expression expression--sentence" id="display">
              <span class="sentence-quote sentence-quote--open">「</span><span>{{#AltDisplay}}{{furigana:AltDisplay}}{{/AltDisplay}}{{^AltDisplay}}{{Sentence}}{{/AltDisplay}}</span><span class="sentence-quote sentence-quote--close">」</span>
            </div>
          {{/IsSentenceCard}}

          {{^IsSentenceCard}}
            <div class="expression expression--word" id="display">
              {{#AltDisplay}}{{furigana:AltDisplay}}{{/AltDisplay}}{{^AltDisplay}}{{Word}}{{/AltDisplay}}
            </div>
          {{/IsSentenceCard}}
        {{/IsTargetedSentenceCard}} 

      {{/IsClickCard}} 

    {{/IsHoverCard}} 


    <!-- appears to the left -->
    <div class="flag-box">
      <svg xmlns="http://www.w3.org/2000/svg" focusable="false" viewBox="0 0 50 50"
        class="flag-box__svg" id="flag_box_svg">
        <circle id="svg_circle" class="flag-box__circle" cx="25" cy="15" r="7">
          <title id=svg_title></title>
        </circle>
      </svg>
    </div>

  </div> <!-- expression box -->

{{/PAShowInfo}} 



{{#HintNotHidden}}
  <div class="center-box-1 hint">
    <div class="center-box-2">
      <div class="bold-yellow">{{HintNotHidden}}</div>
    </div>
  </div>
{{/HintNotHidden}}

<!-- https://stackoverflow.com/questions/1269589/css-center-block-but-align-contents-to-the-left -->
<!-- tl;dr wrap anything you want centered + left justified with center-box-1 and center-box-2 -->
{{#Hint}}
  <details class="hint" id="hint_details">
    <summary>Hint</summary>
    <div class="center-box-1">
      <div class="center-box-2">
        <div class="bold-yellow">{{Hint}}</div>
      </div>
    </div>
  </details>
{{/Hint}}







<center>
  <div class="answer-border"></div>
</center>








<div class="def-header" id="def_header">

  <!-- everything on the left side -->
  
  <div class="dh-left " id="dh_left">

    <div class="dh-left__reading" id="dh_reading"> {{furigana:WordReading}} </div>

    
    <div class="dh-left__word-pitch " id="dh_word_pitch">
      {{AJTWordPitch}}
    </div>

    <div class="dh-left__audio-buttons">
      <span id="word-audio"> {{WordAudio}} </span>
      <span id="sentence-audio"> {{SentenceAudio}} </span>
    </div>

  </div>

  <!-- everything on the right side -->
  {{#Picture}}
  <div class="dh-right" id="dh_right">
    <div class="dh-right__img-container" id="dh_img_container">{{Picture}}</div>
  </div>
  {{/Picture}}

</div>



<div id="back_side" class="back-side">


<div class="center-box-1">
  <div class="center-box-2">
    <div class="full-sentence bold-yellow" id="full_sentence">
      {{#SentenceReading}}
        {{furigana:SentenceReading}}
      {{/SentenceReading}}
      {{^SentenceReading}}
        {{Sentence}}
      {{/SentenceReading}}
    </div>
  </div>
</div>



<blockquote class="glossary-blockquote bold-yellow" id="primary_definition">
  <div class="glossary-text glossary-text--primary-definition">
    {{furigana:PrimaryDefinition}}
  </div>
</blockquote>


{{#SecondaryDefinition}}
  <details class="glossary-details" id="secondary_definition_details">
    <summary>Secondary Definition</summary>
    <blockquote class="glossary-blockquote bold-yellow">
      <div class="glossary-text glossary-text--secondary-definition">
        {{SecondaryDefinition}}
      </div>
    </blockquote>
  </details>
{{/SecondaryDefinition}}
{{^SecondaryDefinition}}
  <div class="glossary-details glossary-details--grey">
    Secondary Definition
  </div>
{{/SecondaryDefinition}}


{{#AdditionalNotes}}
  <details class="glossary-details glossary-details--small" id="additional_notes_details">
    <summary>Additional Notes</summary>
    <blockquote class="glossary-blockquote glossary-blockquote--small bold-yellow">
      <div class="glossary-text glossary-text--additional-notes">
        {{AdditionalNotes}}
      </div>
    </blockquote>
  </details>
{{/AdditionalNotes}}
{{^AdditionalNotes}}
  <div class="glossary-details glossary-details--small glossary-details--grey">
    Additional Notes
  </div>
{{/AdditionalNotes}}

{{#ExtraDefinitions}}
  <details class="glossary-details glossary-details--small" id="extra_definitions_details">
    <summary>Extra Definitions</summary>
    <blockquote class="glossary-blockquote glossary-blockquote--small bold-yellow">
      <div class="glossary-text glossary-text--extra-definitions">
        {{ExtraDefinitions}}
      </div>
    </blockquote>
  </details>
{{/ExtraDefinitions}}
{{^ExtraDefinitions}}
  <div class="glossary-details glossary-details--small glossary-details--grey">
    Extra Definitions
  </div>
{{/ExtraDefinitions}}



<div class="outer-display1
    {{^PAGraphs}}{{^UtilityDictionaries}}
      outer-display2
    {{/UtilityDictionaries}}{{/PAGraphs}}"
  id="display">

  <!-- only showed if outer-display2 doesn't exist -->
  <details class="glossary-details glossary-details--small inner-display1" id="extra_info_details">
    <summary>Extra Info</summary>
    <blockquote class="glossary-blockquote glossary-blockquote--small bold-yellow">
      <div class="glossary-text glossary-text--extra-info">

        {{#PAGraphs}}
          <div class="pa-graphs">
            {{PAGraphs}}
          </div>
        {{/PAGraphs}}

        {{#UtilityDictionaries}}
          <div class="utility-dicts">
            {{UtilityDictionaries}}
          </div>
        {{/UtilityDictionaries}}

      </div>
    </blockquote>
  </details>

  <!-- only showed if outer-display2 exists -->
  <div class="glossary-details glossary-details--small glossary-details--grey inner-display2">
    Extra Info
  </div>

</div>







</div> <!-- backside -->


<!--
  https://codeconvey.com/html-image-zoom-on-click/
  http://www.liangshunet.com/en/202005/743233073.htm
  https://stackoverflow.com/questions/8449933/how-to-transition-css-display-opacity-properties
  https://www.javascripttutorial.net/dom/css/add-styles-to-an-element/
  https://stackoverflow.com/questions/507138/how-to-add-a-class-to-a-given-element
-->
<!-- The Modal -->
<div id="modal" class="modal">
  <img class="modal-img" id="bigimg">
</div>


<script>



/// /// 
// GLOBALS: kanji-hover


// global cache for an entire card's kanji hover html
// maps key.word_reading -> html string
//var kanjiHoverCardCache = kanjiHoverCardCache ?? {};
var kanjiHoverCardCache = nullish(kanjiHoverCardCache, {});

// maps kanji -> [{set of used words}, html string]
//var kanjiHoverCache = kanjiHoverCache ?? {};
var kanjiHoverCache = nullish(kanjiHoverCache, {});


/// 

// GLOBALS: open_on_new


// note that this cache will NOT respect card review undos,
// but that should be a niche enough case to not warrent caching.
// maps key -> bool
var isNewCardCache = nullish(isNewCardCache, {});

/// 
(function () { // restricts ALL javascript to hidden scope

// "global" variables within the hidden scope
let note = (function () {
  let my = {};
  return my;
}());



function getSetting(keys, defaultVal) {
  if (typeof JPMNOpts === "undefined") {
    return defaultVal;
  }

  let keyList = ["settings"].concat(keys);

  let obj = JPMNOpts;
  for (let key of keyList) {
    if (!(key in obj)) {

      // checks if we need to warn, manual search
      if ("settings" in JPMNOpts && "debug" in JPMNOpts["settings"] && JPMNOpts["settings"]["debug"]) {
        LOGGER.warn("Option " + keys.join(".") + " is not defined in the options file.");
      }
      return defaultVal;
    }
    obj = obj[key];
  }
  return obj;
};


/*
 * Toggles the display of any given details tag
 */
function toggleDetailsTag(ele) {
  if (ele.hasAttribute('open')) {
    ele.removeAttribute('open');
  } else {
    ele.setAttribute("open", "true");
  }
}


// START_BLOCK: js_functions





// https://github.com/FooSoft/anki-connect#javascript
function invoke(action, params={}) {
  let version = 6;
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.addEventListener('error', () => reject('failed to issue request'));
    xhr.addEventListener('load', () => {
      try {
        const response = JSON.parse(xhr.responseText);
        if (Object.getOwnPropertyNames(response).length != 2) {
          throw 'response has an unexpected number of fields';
        }
        if (!response.hasOwnProperty('error')) {
          throw 'response is missing required error field';
        }
        if (!response.hasOwnProperty('result')) {
          throw 'response is missing required result field';
        }
        if (response.error) {
          throw response.error;
        }
        resolve(response.result);
      } catch (e) {
        reject(e);
      }
    });

    xhr.open('POST', 'http://127.0.0.1:8765');
    xhr.send(JSON.stringify({action, version, params}));
  });
}



const HIRAGANA_CONVERSION_RANGE = [0x3041, 0x3096];
const KATAKANA_CONVERSION_RANGE = [0x30a1, 0x30f6];
const KATAKANA_RANGE = [0x30a0, 0x30ff];

// copied/pasted directly from yomichan
// https://github.com/FooSoft/yomichan/blob/master/ext/js/language/sandbox/japanese-util.js
// I have no idea what is going on tbh but it seems to work
function isCodePointInRange(codePoint, [min, max]) {
  return (codePoint >= min && codePoint <= max);
}

function convertHiraganaToKatakana(text) {
  let result = '';
  const offset = (KATAKANA_CONVERSION_RANGE[0] - HIRAGANA_CONVERSION_RANGE[0]);
  for (let char of text) {
    const codePoint = char.codePointAt(0);
    if (isCodePointInRange(codePoint, HIRAGANA_CONVERSION_RANGE)) {
      char = String.fromCodePoint(codePoint + offset);
    }
    result += char;
  }
  return result;
}

/// 



function hybridClick() {
  const hSent = document.getElementById("hybrid-sentence");
  const hWord = document.getElementById("hybrid-word");
  const svgEle = document.getElementById("flag_box_svg");
  const circ = document.getElementById("svg_circle");

  if (hSent.classList.contains("override-display-inline-block")) {
    // currently showing sentence, change to word
    hWord.classList.remove("override-display-none");
    hSent.classList.remove("override-display-inline-block");
    if (circ !== null) {
      circ.setAttributeNS(null, "cx", "25");
      circ.setAttributeNS(null, "cy", "15");
    }

    // re-adds if colored quotes exist
    if (svgEle !== null && hSent.hasAttribute("data-color-quotes")) {
      svgEle.style.display = "initial";
    }

  } else {
    // currently showing word, change to sentence
    hWord.classList.add("override-display-none");
    hSent.classList.add("override-display-inline-block");
    if (circ !== null) { // sentence
      if (hSent.innerText.length > 0 && hSent.innerText[0] === "「") {
        circ.setAttributeNS(null, "cx", "35");
        circ.setAttributeNS(null, "cy", "11");
      }
    }

    // removes if colored quotes exist
    if (svgEle !== null && hSent.hasAttribute("data-color-quotes")) {
      svgEle.style.display = "none";
    }
  }
}

/// 
/// 
// END_BLOCK: js_functions







// ================
//  Sentence Utils
// ================
//
// processes the sentence
// - removes newlines
// - replaces bold with [...] if cloze deletion
// - handles adding or replacing quotes if specified

const JPMNSentUtils = (() => {
  const logger = new JPMNLogger("sent-utils");

  function processSentence(sentEle, isAltDisplay, isClozeDeletion, paIndicator) {
    if (typeof isAltDisplay === 'undefined') {
      LOGGER.warn("isAltDisplay is undefined");
      isAltDisplay = false;
    }

    // removes linebreaks
    let result = sentEle.children[1].innerHTML;

    // cloze deletion replacing bold with [...]
    if (typeof isClozeDeletion !== "undefined" && isClozeDeletion) {
      result = result.replace(/<b>.*?<\/b>/g, "<b>[...]</b>");
    }

    if ((!isAltDisplay && getSetting(['modules','sent-utils','remove-line-breaks',],false))
        || isAltDisplay && getSetting(['modules','sent-utils','remove-line-breaks-on-altdisplay',],false)) {
      let noNewlines = result.replace(/<br>/g, "");

      result = noNewlines;
    }

    // removes leading and trailing white space (equiv. of strip() in python)
    result = result.trim();

    let validQuotes = getSetting(['modules','sent-utils','quote-match-strings',],[['「', '」'], ['『', '』']]);
    let existingQuote = false;

    let openQuoteEle = sentEle.children[0];
    let closeQuoteEle = sentEle.children[2];

    for (let quotePair of validQuotes) {
      if ((result[0] === quotePair[0]) && (result[result.length-1] === quotePair[1])) {

        // adds quote to surrounding divs
        let openQuote = null;
        let closeQuote = null;
        [openQuote, closeQuote] = quotePair;
        openQuoteEle.innerText = openQuote;
        closeQuoteEle.innerText = closeQuote;

        result = result.slice(1, -1);
        existingQuote = true;
        break;
      }
    }

    let autoQuote = (
      (!isAltDisplay && getSetting(['modules','sent-utils','auto-quote-sentence',],true))
      || (isAltDisplay && getSetting(['modules','sent-utils','auto-quote-alt-display-sentence',],true))
    );
    if (!existingQuote && autoQuote) {
      /// 
      openQuoteEle.innerText = getSetting(['modules','sent-utils','auto-quote-open',],'「');
      closeQuoteEle.innerText = getSetting(['modules','sent-utils','auto-quote-close',],'」');
      /// 
    }

    // no quotes are added
    if (!existingQuote && !autoQuote) {
      // note that it defaults to having quotes + auto align without this module being ran
      // hence why all these steps have to be done
      openQuoteEle.innerText = "";
      closeQuoteEle.innerText = "";

      sentEle.style["text-indent"] = "0em";
      sentEle.style["padding-left"] = "0em";
    }


    // data-color-quotes: INDICATOR if the sentence quotes are colored or not
    // - attribute doesn't exist by default
    // - if exists, then the quotes are colored
    // - added in the sections below:

    /// 

    /// 
    /// {{#PAShowInfo}}

    // moves pa-indicator position
    if (!existingQuote && !autoQuote) {
      const circ = document.getElementById("svg_circle");
      if (circ !== null) {
        circ.setAttributeNS(null, "cx", "35");
        circ.setAttributeNS(null, "cy", "11");
      }
    }

    if ((existingQuote || autoQuote) && getSetting(['modules','sent-utils','pa-indicator-color-quotes',],false)) {
      // TODO change this to a data-color-quotes tag within html
      // so it is sentence-div dependent
      sentEle.setAttribute("data-color-quotes", "true");

      if (paIndicator !== null) {
        openQuoteEle.classList.add(paIndicator.className);
        closeQuoteEle.classList.add(paIndicator.className);
      }

      /// {{#IsHoverCard}}
      let elems = document.getElementsByClassName("expression__hybrid-wrapper");
      if (elems.length > 0) {
        elems[0].classList.add("expression__hybrid-wrapper--hover-remove-flag");
      }
      /// {{/IsHoverCard}}

      // neither hover & click and is either one of TSC / sentence -> removes flag
      let svgEle = document.getElementById("flag_box_svg");

      /// ///{{^IsHoverCard}}///{{^IsClickCard}}
      /// ///{{#IsTargetedSentenceCard}}///{{^IsSentenceCard}}
      svgEle.style.display = "none";
      /// ///{{/IsSentenceCard}}///{{/IsTargetedSentenceCard}}///{{^IsTargetedSentenceCard}}///{{#IsSentenceCard}}
      svgEle.style.display = "none";
      /// ///{{/IsSentenceCard}}///{{/IsTargetedSentenceCard}}///{{#IsTargetedSentenceCard}}///{{#IsSentenceCard}}
      svgEle.style.display = "none";
      /// ///{{/IsSentenceCard}}///{{/IsTargetedSentenceCard}}
  


      /// ///{{/IsClickCard}}///{{/IsHoverCard}}

      // ASSUMPTION: IsClickCard + back side of the main card -> reveals sentence
      // i.e. hybridClick() is automatically called
      // ASSUMPTION: hybridClick() is called BEFORE this section
      /// 
      /// {{#IsClickCard}}
      svgEle.style.display = "none";
      /// {{/IsClickCard}}
      /// 
    }
    /// {{/PAShowInfo}}
    /// 

    sentEle.children[1].innerHTML = result;

  }


  class JPMNSentUtils {
    constructor(isAltDisplay, isClozeDeletion, paIndicator) {
      this.isAltDisplay = isAltDisplay;
      this.isClozeDeletion = nullish(isClozeDeletion, false);
      this.paIndicator = nullish(paIndicator, null);
    }

    run() {
      let sentences = document.querySelectorAll(".expression--sentence")

      if (sentences !== null) {
        for (let sent of sentences) {
          processSentence(sent, this.isAltDisplay, this.isClozeDeletion, this.paIndicator);
        }
      }
    }
  }


  return JPMNSentUtils;

})();


/// 




// =============
//  Kanji Hover
// =============

const JPMNKanjiHover = (() => {

  const logger = new JPMNLogger("kanji-hover");

  // element outside async function to prevent double-adding due to anki funkyness
  const wordReading = document.getElementById("dh_reading");
  let kanjiHoverEnabled = false;

  // multi query result, in the format of
  // [kanji 1 (non-new), kanji 1 (new), kanji 2 (non-new), kanji 2 (new), etc.]
  async function cardQueries(kanjiArr) {
    const cardTypeName = 'Mining Card';

    function constructFindCardAction(query) {
      return {
        "action": "findCards",
        "params": {
          "query": query,
        }
      }
    }

    // constructs the multi findCards request for ankiconnect
    let actions = [];
    for (const character of kanjiArr) {
      const baseQuery = (
        `(-"Key:{{Key}}" -"WordReading:{{WordReading}}"`
        + `Word:*${character}* "card:${cardTypeName}") `
      );
      const nonNewQuery = baseQuery + getSetting(['modules','kanji-hover','non-new-query',],'(-is:new OR (is:new flag:3)) -(is:suspended flag:1)');
      const newQuery = baseQuery + getSetting(['modules','kanji-hover','new-query',],'is:new -(is:suspended (flag:1 OR flag:3))');

      actions.push(constructFindCardAction(nonNewQuery))
      actions.push(constructFindCardAction(newQuery))
    }

    return await invoke("multi", {"actions": actions})
  }

  function filterCards(nonNewCardIds, newCardIds) {
    const nonNewEarliest = getSetting(['modules','kanji-hover','max-non-new-oldest',],2);
    const nonNewLatest = getSetting(['modules','kanji-hover','max-non-new-latest',],2);
    const newLatest = getSetting(['modules','kanji-hover','max-new-latest',],2);

    // non new: gets the earliest and latest
    let nonNewResultIds = []
    if (nonNewCardIds.length > nonNewEarliest + nonNewLatest) {
      nonNewResultIds = [
        ...nonNewCardIds.slice(0, nonNewEarliest), // earliest
        ...nonNewCardIds.slice(-nonNewLatest, nonNewCardIds.length), // latest
      ];
    } else {
      nonNewResultIds = [...nonNewCardIds];
    }

    let newResultIds = newCardIds.slice(0, newLatest);

    return [nonNewResultIds, newResultIds];
  }



  async function getCardsInfo(queryResults) {
    function constructCardsInfoAction(idList) {
      return {
        "action": "cardsInfo",
        "params": {
          "cards": idList,
        }
      }
    }

    let actions = [];
    logger.assert(queryResults.length % 2 == 0, "query results not even");

    for (let i = 0; i < queryResults.length/2; i++) {
      // ids are equivalent to creation dates, so sorting ids is equivalent to
      // sorting to card creation date
      const nonNewCardIds = queryResults[i*2].sort();
      const newCardIds = queryResults[i*2 + 1].sort();
      const [nonNewResultIds, newResultIds] = filterCards(nonNewCardIds, newCardIds)

      // creates a multi request of the following format:
      // [cardInfo (nonNewCardIds, kanji 1), cardInfo (newCardIds, kanji 1), etc.]
      actions.push(constructCardsInfoAction(nonNewResultIds))
      actions.push(constructCardsInfoAction(newResultIds))
    }

    return await invoke("multi", {"actions": actions})
  }


  // taken directly from anki's implementation of { {furigana:...} }
  // https://github.com/ankitects/anki/blob/main/rslib/src/template_filters.rs
  function buildWordDiv(character, wordReading) {

    const wordDiv = document.createElement('div');
    const re = / ?([^ >]+?)\[(.+?)\]/g

    //let wordReadingRuby = wordReading.replaceAll("&nbsp;", " ");
    let wordReadingRuby = wordReading.replace(/&nbsp;/g, " ");
    wordReadingRuby = wordReadingRuby.replace(re, "<ruby><rb>$1</rb><rt>$2</rt></ruby>");
    //wordReadingRuby = wordReadingRuby.replaceAll(character, `<b>${character}</b>`);
    wordReadingRuby = wordReadingRuby.replace(new RegExp(character, "g"), `<b>${character}</b>`);

    wordDiv.innerHTML = wordReadingRuby;
    return wordDiv;
  }

  function buildSentDiv(sentence) {
    const sentenceSpan = document.createElement('span');

    let resultSent = sentence;
    //resultSent = resultSent.replaceAll("<b>", "");
    //resultSent = resultSent.replaceAll("</b>", "");
    resultSent = resultSent.replace(/<b>/g, "");
    resultSent = resultSent.replace(/<\/b>/g, "");
    sentenceSpan.innerHTML = resultSent;

    const openQuote = document.createElement('span');
    openQuote.innerText = "「";
    const closeQuote = document.createElement('span');
    closeQuote.innerText = "」";


    const sentenceDiv = document.createElement('div');
    sentenceDiv.classList.add("left-align-quote");

    sentenceDiv.appendChild(openQuote);
    sentenceDiv.appendChild(sentenceSpan);
    sentenceDiv.appendChild(closeQuote);

    return sentenceDiv;
  }

  function buildCardDiv(character, card, isNew=false) {
    const cardDiv = document.createElement('div');
    const wordDiv = buildWordDiv(character, card["fields"]["WordReading"]["value"]);
    const sentenceDiv = buildSentDiv(card["fields"]["Sentence"]["value"]);

    cardDiv.appendChild(wordDiv);
    cardDiv.appendChild(sentenceDiv);

    if (isNew) {
      cardDiv.classList.add("kanji-hover-tooltip--new");
    }

    return cardDiv;
  }

  function buildString(character, nonNewCardInfo, newCardInfo) {

    /*
     * <span class="kanji-hover-wrapper">
     *   <span class="kanji-hover-text"> (kanji) </span>
     *   <span class="kanji-hover-tooltip-wrapper">
     *     <span class="kanji-hover-tooltip"> ... </span>
     *   </span>
     * </span>
     *
     */

    // wrapper element that isn't used, to get the inner html

    const kanjiHoverWrapper = document.createElement('span');
    kanjiHoverWrapper.classList.add("kanji-hover-wrapper");


    const kanjiSpan = document.createElement('span');
    kanjiSpan.classList.add("kanji-hover-text");
    kanjiSpan.innerText = character;

    tooltipWrapperSpan = document.createElement('span');
    tooltipWrapperSpan.classList.add("kanji-hover-tooltip-wrapper");

    tooltipSpan = document.createElement('span');
    tooltipSpan.classList.add("kanji-hover-tooltip");

    let count = 0;


    for (const card of nonNewCardInfo) {
      const cardDiv = buildCardDiv(character, card);
      if (count >= 1) {
        cardDiv.classList.add("kanji-hover-tooltip--not-first");
      }
      count++;

      tooltipSpan.appendChild(cardDiv);
    }

    for (const card of newCardInfo) {
      const cardDiv = buildCardDiv(character, card, isNew=true);
      if (count >= 1) {
        cardDiv.classList.add("kanji-hover-tooltip--not-first");
      }
      count++;

      tooltipSpan.appendChild(cardDiv);
    }


    // 0 length checks
    if (nonNewCardInfo.length + newCardInfo.length == 0) {
      tooltipSpan.innerText = "No other kanjis found.";
    }

    tooltipWrapperSpan.appendChild(tooltipSpan)
    kanjiHoverWrapper.appendChild(kanjiSpan);
    kanjiHoverWrapper.appendChild(tooltipWrapperSpan);

    return kanjiHoverWrapper.outerHTML;
  }


  function getWordReadings(nonNewCardInfo, newCardInfo) {
    let wordsArr = []

    for (const card of nonNewCardInfo) {
      wordsArr.push(card["fields"]["WordReading"]["value"])
    }
    for (const card of newCardInfo) {
      wordsArr.push(card["fields"]["WordReading"]["value"])
    }

    return wordsArr;
  }



  // kanji hover
  // some code shamelessly stolen from cade's kanji hover:
  // https://github.com/cademcniven/Kanji-Hover/blob/main/_kanjiHover.js

  async function kanjiHover() {

    if (kanjiHoverEnabled) {
      logger.debug("Kanji hover is already enabled");
      return;
    }
    kanjiHoverEnabled = true;

    // realistically, key should be good enough since we assume that key has no duplicates
    // however, just in case, wordreading is added
    const cacheKey = "{{Key}}.{{WordReading}}"
    if (cacheKey in kanjiHoverCardCache) {
      logger.debug("Card was cached")
      wordReading.innerHTML = kanjiHoverCardCache[cacheKey];
      return;
    }

    const readingHTML = wordReading.innerHTML;

    // uses cache if it already exists
    let kanjiSet = new Set() // set of kanjis that requires api calls
    const regex = /([\u4E00-\u9FAF])(?![^<]*>|[^<>]*<\/g)/g;
    const matches = readingHTML.matchAll(regex);
    for (const match of matches) {
      kanjiSet.add(...match);
    }

    let kanjiDict = {};
    let wordReadings = {}; // used only for the cache

    // attempts to fill out the kanji dict with cached entries
    for (let kanji of [...kanjiSet]) {
      // also checks that the current word is not used
      if ((kanji in kanjiHoverCache) && !(kanjiHoverCache[kanji][0].includes("{{WordReading}}"))) {
        logger.debug(`Using cached kanji ${kanji}`)
        kanjiDict[kanji] = kanjiHoverCache[kanji][1];
        kanjiSet.delete(kanji);
      }
    }

    // only calls the api on the needed kanjis
    const kanjiArr = [...kanjiSet];
    const queryResults = await cardQueries(kanjiArr);
    const cardsInfo = await getCardsInfo(queryResults);

    logger.debug(`New kanjis: [${kanjiArr.join(", ")}]`)

    for (const [i, character] of kanjiArr.entries()) {
      let nonNewCardInfo = cardsInfo[i*2];
      let newCardInfo = cardsInfo[i*2 + 1];

      // attempts to insert string
      kanjiDict[character] = buildString(character, nonNewCardInfo, newCardInfo);
      wordReadings[character] = getWordReadings(nonNewCardInfo, newCardInfo);
    }

    const re = new RegExp(Object.keys(kanjiDict).join("|"), "gi");
    const resultHTML = readingHTML.replace(re, function (matched) {
      //return kanjiDict[matched] ?? matched;
      return nullish(kanjiDict[matched], matched);
    });

    wordReading.innerHTML = resultHTML;

    // caches card
    kanjiHoverCardCache[cacheKey] = resultHTML;

    for (const character of kanjiArr) {
      kanjiHoverCache[character] = [wordReadings[character], kanjiDict[character]];
    }

  }


  class JPMNKanjiHover {
    constructor() {}

    async run() {
      kanjiHover();
    }
  }


  return JPMNKanjiHover;

})();

/// 




// ==========================
//  Auto Select Pitch Accent
// ==========================
// sets the pitch accent section to be whatever you specify it
// by the pitch accent position number

const JPMNAutoPA = (() => {


  const logger = new JPMNLogger("auto-pitch-accent");

  const ele = document.getElementById("hidden_pa_positions");
  const eleAJT = document.getElementById("hidden_ajt_word_pitch");
  const eleOverride = document.getElementById("hidden_pa_override");
  const eleDisp = document.getElementById("dh_word_pitch");

  // returns null if cannot find anything
  // otherwise, returns (position (int), dict_name (str))
  // dict_name can be null
  function getPosition() {
    let digit = null;

    if (ele === null) {
      return null;
    }

    // first checks pa override
    digit = eleOverride.innerText.match(/\d+/)
    if (digit !== null) {
      return [Number(digit), "override"];
    }

    let searchHTML = null;
    let dictName = null;
    if ((ele.children.length > 0)
        && (ele.children[0] !== null)
        && (ele.children[0].nodeName === "DIV")
        && (ele.children[0].classList.contains("pa-positions__group"))
    ) {
      // stylized by jpmn standards, walks through

      // <div class="pa-positions__group" data-details="NHK">
      //   <div class="pa-positions__dictionary"><div class="pa-positions__dictionary-inner">NHK</div></div>
      //   <ol>
      //     <li>
      //       <span style="display: inline;"><span>[</span><span>1</span><span>]</span></span>
      //     </li>
      //   </ol>
      // </div>
      // ...

      dictName = ele.children[0].getAttribute("data-details");

      // searches for a bolded element
      let first = true;
      let found = false;
      for (const groupDiv of ele.children) {
        for (const liEle of groupDiv.children[1].children) {
          if (first) {
            first = false;
            searchHTML = liEle.innerHTML;
          }
          if (liEle.innerHTML.includes("<b>")) {
            searchHTML = liEle.innerHTML;
            dictName = groupDiv.getAttribute("data-details") + " (bold)";
            found = true;
            break;
          }
        }

        if (found) {
          break;
        }
      }

    } else {
      // just search for any digit in the element
      searchHTML = ele.innerHTML;
    }

    digit = searchHTML.match(/\d+/);
    if (digit === null) {
      return null;
    }

    return [Number(digit), dictName];
  }

  // taken directly from anki's implementation of { {kana:...} }
  // https://github.com/ankitects/anki/blob/main/rslib/src/template_filters.rs
  function getReadingKana() {
    const readingStr = document.getElementById("hidden_word_reading").innerHTML;

    const re = / ?([^ >]+?)\[(.+?)\]/g

    //let result = readingStr.replaceAll("&nbsp;", " ");
    let result = readingStr.replace(/&nbsp;/g, " ");
    result = readingStr.replace(re, "$2");

    return result;
  }

  const EXTENDED_VOWELS = {
    "ア": "ナタサカワラヤマハャパバダザガ",
    "イ": "ニチシキリミヒピビヂジギ" + "ネテセケレメヘペベデゼゲ",
    "ウ": "ヌツスクルユムフュプブヅズグ" + "ノトソコヲロヨモホョポボドゾゴ",
    "エ": "ネテセケレメヘペベデゼゲ",
    "オ": "ノトソコヲロヨモホョポボドゾゴ",
  };

  // function name gore :sob:
  function convertHiraganaToKatakanaWithLongVowelMarks(reading) {
    // converts to katakana and changes vowels to extended vowel form
    const katakana = convertHiraganaToKatakana(reading);
    let result = [...katakana];

    for (let i = 1; i < result.length; i++) {
      if (result[i] in EXTENDED_VOWELS && EXTENDED_VOWELS[result[i]].includes(result[i-1])) {
        result[i] = "ー";
      }
    }

    return result.join("");
  }


  function getMoras(readingKana) {
    // creates div
    const ignoredKana = "ょゅゃョュャ";
    const len = [...readingKana].length;

    // I think the plural of mora is mora, but oh well
    let moras = [];

    let currentPos = 0;
    while (currentPos < len) {
      // checks next kana to see if it's a combined mora (i.e. きょ)
      // ignoredKana.includes(...) <=> ... in ignoredKana
      if (currentPos !== (len-1) && ignoredKana.includes(readingKana[currentPos+1])) {
        moras.push(readingKana.substring(currentPos, currentPos+2));
        currentPos++;
      } else {
        moras.push(readingKana[currentPos])
      }
      currentPos++;
    }

    return moras;
  }


  const LONG_VOWEL_MARKER_TO_VOWEL = {
    "アナタサカワラヤマハャパバダザガ": "ア",
    "イニチシキリミヒピビヂジギ":       "イ",
    "ウヌツスクルユムフュプブヅズグ":   "ウ",
    "エネテセケレメヘペベデゼゲ":       "イ", // "エ",
    "ノトソコヲロヨモホョポボドゾゴ":   "ウ", // "オ",
    "オ": "オ", // "オ",
  }

  function normalizeAJTHTML() {
    // replaces all long katakana markers with the respective normal katakana symbol
    // also removes all ꜜ (remember that we can search for downsteps from the now empty div)

    let result = eleAJT.innerHTML.replace(/&#42780/g, "").replace(/ꜜ/g, "");

    // replaces all nasal entries
    if (result.includes("nasal")) {
      const unmarked = "カキクケコ";
      const marked = "ガギグゲゴ"; // I actually don't know what the two ticks are called

      // 5 is length of unmarked and marked
      for (let i = 0; i < 5; i++) {
        result = result.replace(new RegExp(`${unmarked[i]}<span class="nasal">°</span>`, "g"), marked[i]);
      }
    }
    logger.assert(!result.includes("nasal"));

    result = [...result];


    let first = null;
    let second = null;

    for (const [i, c] of result.entries()) {
      if (isCodePointInRange(c.codePointAt(0), KATAKANA_RANGE)) {
        if (first === null) {
          first = c;
        } else if (second === null) {
          second = c;
        } else {
          // pushes back
          first = second;
          second = c;
        }

        if (first !== null && second !== null && second === "ー") {
          let found = false;
          for (const [searchStr, vowel] of Object.entries(LONG_VOWEL_MARKER_TO_VOWEL)) {
            if (searchStr.includes(first)) {
              result[i] = vowel;
              found = true;
              break;
            }
          }

          if (!found) {
            logger.debug(`Cannot find replacement! ${first} ${second}`);
          }
        }
      }
    }

    return result.join("");
  }


  function getAJTWord(hiraganaReading) {
    const normalizedReading = convertHiraganaToKatakana(hiraganaReading);
    // grabs the raw html split between the ・ characters
    // ASSUMPTION: no html element is split between the ・ characters
    // (apart from <b>, which are ignored)

    if (eleAJT.innerHTML.length === 0) {
      logger.debug(`AJT word: empty field`);
      return null;
    }

    // normalizes the ajt search string
    const ajtHTML = normalizeAJTHTML();

    // temp used for innerText
    let temp = document.createElement("div");
    temp.innerHTML = ajtHTML;
    const searchString = temp.innerText;
    const wordSearch = searchString.split("・");
    const idx = wordSearch.indexOf(normalizedReading)

    if (idx === -1) {
      logger.debug(`AJT word: ${normalizedReading} not found among [${wordSearch.join(", ")}]`);
      return null;
    }

    if (wordSearch.length === 1) {
      return eleAJT.innerHTML;
    }

    // otherwise searches on the raw html
    let startIdx = 0;
    let endIdx = 0;
    let currentWord = 0;
    for (const [i, c] of [...eleAJT.innerHTML].entries()) {
      if (c === "・") {
        currentWord += 1;

        if (currentWord === idx) {
          startIdx = i+1;
        } else if (currentWord === idx+1) {
          endIdx = i;
          break
        }
      }
    }

    if (endIdx === 0) {
      endIdx = eleAJT.innerHTML.length
    }

    result = eleAJT.innerHTML.substring(startIdx, endIdx);

    // removes any bold in case it messes with the formatting
    result = result.replace(/<b>/g, "");
    result = result.replace(/<\/b>/g, "");

    return result;
  }


  function buildReadingSpan(pos, readingKana) {
    // creates the span to show the pitch accent overline
    // (and attempts to get any existing nasal / devoiced things from the AJT pitch accent plugin)

    let ajtWord = null;
    if (getSetting(['modules','auto-pitch-accent','search-for-ajt-word',],true)) {
      ajtWord = getAJTWord(readingKana);
    }

    let result = [];

    if (ajtWord !== null) {
      logger.debug("Using AJT Word");

      // temp element to iterate through childnodes of ajt word
      const temp = document.createElement("div");

      // temp element to store the flattened version of the ajt word div
      // and for converting into a list of moras
      const temp2 = document.createElement("div");
      temp.innerHTML = ajtWord;

      // removes pitch accent overline and downstep
      for (const x of temp.childNodes) {
        if (x.nodeName === "SPAN" && x.classList.contains("pitchoverline")) {
          for (const child of x.childNodes) {
            temp2.appendChild(child.cloneNode(true));
          }
        } else if (x.nodeName === "SPAN" && x.classList.contains("downstep")) {
          // skips
        } else {
          temp2.appendChild(x.cloneNode(true));
        }
      }

      // combines the devoiced character into one mora, if it can
      // (e.g. 神出鬼没 (しんしゅつきぼつ) only has the 2nd (し) devoiced, instead of (しゅ)
      // シ<span class="pitchoverline">ン<span class="nopron">シ</span>ュツキボツ</span>
      if (ajtWord.includes("nopron")) {
        // crazy regex replace
        temp2.innerHTML = temp2.innerHTML.replace(
          /<span class="nopron">(.)<\/span>([ュャョ])/g,
          '<span class="nopron">$1$2<\/span>'
        );
      }

      for (const x of temp2.childNodes) {
        if (x.nodeName === "#text") {
          const moras = getMoras(x.data);
          result = result.concat(moras);
        } else if (x.nodeName === "SPAN" && x.classList.contains("nasal")) {
          // assumption: there already exists at least one element before
          // (the nasal marker can't come by itself)
          result[result.length-1] = result[result.length-1] + x.outerHTML;
        } else {
          // assumption: this is the nopron span
          result.push(x.outerHTML);
        }
      }

    } else {
      logger.debug(`Using reading from WordReading field`);

      let normalizedReading = null;
      switch (getSetting(['modules','auto-pitch-accent','reading-display-mode',],2)) {
        case 0:
          normalizedReading = readingKana;
          break;

        case 1:
          normalizedReading = convertHiraganaToKatakana(readingKana);
          break;

        case 2:
          normalizedReading = convertHiraganaToKatakanaWithLongVowelMarks(readingKana);
          break;

        default:
          throw 'Invalid option for modules.auto-pitch-accent.reading-display-mode';
      }

      result = getMoras(normalizedReading);

      logger.debug(`Moras: ${normalizedReading} -> ${result.join(", ")}`);
    }

    if (result.length === 0) {
      logger.warn("Reading has length of 0?");
      return;
    }

    // special case: 0 and length of moras === 1 (nothing needs to be done)
    if (pos === 0 && result.length === 1) {
      return readingKana;
    }

    const startOverline = '<span class="pitchoverline">';
    const stopOverline = `</span>`;
    const downstep = '<span class="downstep"><span class="downstep-inner">ꜜ</span></span>';

    if (pos === 0) {
      result.splice(1, 0, startOverline); // insert at index 1
      result.push(stopOverline)
    } else if (pos === 1) {
      // start overline starts at the very beginning
      result.splice(pos, 0, stopOverline + downstep);
      result.splice(0, 0, startOverline); // insert at the very beginning
    } else {
      // start overline starts over the 2nd mora
      result.splice(pos, 0, stopOverline + downstep);
      result.splice(1, 0, startOverline); // insert at the very beginning
    }

    result = result.join("");
    return result;

  }

  // main function
  function addPosition() {
    // priority:
    // - PA Override number
    // - PA Override raw text
    // - PA Positions
    // - AJT Word Pitch

    // first checks pa override
    let posResult = null;
    if (eleOverride.innerHTML.length !== 0) {
      const digit = eleOverride.innerText.match(/\d+/)
      if (digit !== null) {
        posResult = [Number(digit), "Override (Position)"];
      } else {
        eleDisp.innerHTML = eleOverride.innerHTML;
        posResult = [null, "Override (Text)"];
      }
    } else {
      // if no PA override, checks PAPositions field
      posResult = getPosition();
    }

    // if no PAPositions or PA Override, then check AJTWordPitch
    if (posResult === null) {
      // last resort: AJT pitch accent
      if (eleAJT.innerHTML.length !== 0) {
        eleDisp.innerHTML = eleAJT.innerHTML;
        posResult = [null, "AJT Pitch Accent"];
      } else {
        logger.debug("Nothing found.");
        eleDisp.innerText = "(N/A)";
        return;
      }
    }

    const [pos, dictName] = posResult;
    const readingKana = getReadingKana();
    logger.debug(`pos/dict/reading: ${pos} ${dictName} ${readingKana}`);

    // if pos is null, then the display element has already been set
    if (pos === null) {
      return;
    }

    const readingSpanHTML = buildReadingSpan(pos, readingKana);
    eleDisp.innerHTML = readingSpanHTML;

    //if (dictName !== null) {
    //  // TODO
    //}

  }

  class JPMNAutoPA {

    constructor() {}

    run() {
      addPosition();
    }
  }


  return JPMNAutoPA;

})();

/// 




// =============
//  Image Utils
// =============

const JPMNImgUtils = (() => {

  const logger = new JPMNLogger("img-utils");

  const modal = document.getElementById('modal');
  const modalImg = document.getElementById("bigimg");

  // creates a custom image container to hold yomichan images
  function createImgContainer(imgName) {
    // creating this programmically:
    // <span class="glossary__image-container">
    //   <a class="glossary__image-hover-text" href='javascript:;'</a>
    //   <img class="glossary__image-hover-media" src="${imgName}">
    // </span>

    const defSpan = document.createElement('span');
    defSpan.classList.add("glossary__image-container");

    const defAnc = document.createElement('a');
    defAnc.classList.add("glossary__image-hover-text");
    defAnc.href = "javascript:;";
    defAnc.textContent = "[Image]";

    const defImg = document.createElement('img');
    defImg.classList.add("glossary__image-hover-media");
    defImg.src = imgName;

    defImg.onclick = function() {
      modal.style.display = "block";
      modalImg.src = this.src;
    }

    defAnc.onclick = function() {
      modal.style.display = "block";
      modalImg.src = defImg.src;
    }

    defSpan.appendChild(defAnc);
    defSpan.appendChild(defImg);

    return defSpan;
  }


  function editDisplayImage() {
    // edits the display image width/height
    // makes the display image clickable to zoom
    // makes the modal clickable to un-zoom

    // restricting the max height of image to the definition box
    const dhLeft = document.getElementById("dh_left");
    const dhRight = document.getElementById("dh_right");
    const heightLeft = dhLeft.offsetHeight;

    if (dhRight) {
      dhRight.style.maxHeight = heightLeft + "px";

      // setting up the modal styles and clicking
      const dhImgContainer = document.getElementById("dh_img_container");
      const imgList = dhImgContainer.getElementsByTagName("img");

      if (imgList && imgList.length === 1) {
        const img = dhImgContainer.getElementsByTagName("img")[0];
        img.classList.add("dh-right__img");
        img.style.maxHeight = heightLeft + "px"; // restricts max height here too

        img.onclick = function() {
          modal.style.display = "block";
          modalImg.src = this.src;
        }

      } else { // otherwise we hope that there are 0 images here
        // support for no images here: remove the fade-in / fade-out on text
        // the slightly hacky method is just to remove the class all together lol
        dhImgContainer.className = "";
      }
    }


    // close the modal upon click
    modal.onclick = function() {
      bigimg.classList.add("modal-img__zoom-out");
      modal.classList.add("modal-img__zoom-out");
      setTimeout(function() {
        modal.style.display = "none";
        bigimg.className = "modal-img";
        modal.className = "modal";
      }, 200);
    }

  }

  function searchImages() {

    // goes through each blockquote and searches for yomichan inserted images
    const imageSearchElements = document.getElementsByTagName("blockquote");
    for (const searchEle of imageSearchElements) {
      const anchorTags = searchEle.getElementsByTagName("a");
      for (const atag of anchorTags) {
        const imgFileName = atag.getAttribute("href");
        if (imgFileName && imgFileName.substring(0, 25) === "yomichan_dictionary_media") {
          logger.debug(`Converting yomichan image ${imgFileName}...`);
          const fragment = createImgContainer(imgFileName);
          atag.parentNode.replaceChild(fragment, atag);
        }
      }

      // looks for user inserted images
      const imgTags = searchEle.getElementsByTagName("img");
      for (const imgEle of imgTags) {
        if (!imgEle.classList.contains("glossary__image-hover-media")) { // created by us
          logger.debug(`Converting user-inserted image ${imgEle.src}...`);
          const fragment = createImgContainer(imgEle.src);
          imgEle.parentNode.replaceChild(fragment, imgEle);
        }
      }
    }
  }

  class JPMNImgUtils {
    constructor() {}

    run() {
      editDisplayImage();

      // may have to disable this for template {edit:} functionality
      if (getSetting(['modules','img-utils','stylize-images-in-glossary',],true)) {
        searchImages();
      }
    }
  }


  return JPMNImgUtils;

})();



/// 




// ===================
//  Open Field on New
// ===================

const JPMNOpenOnNew = (() => {

  // placed outside due to anki's async weirdness
  const primaryDefinitionDetailsEle = document.getElementById("primary_definition_details");
  const secondaryDefinitionDetailsEle = document.getElementById("secondary_definition_details");
  const additionalNotesDetailsEle = document.getElementById("additional_notes_details");
  const extraDefinitionsDetailsEle = document.getElementById("extra_definitions_details");
  const extraInfoDetailsEle = document.getElementById("extra_info_details");

  const strToEle = {
    "Primary Definition": primaryDefinitionDetailsEle,
    "Secondary Definition": secondaryDefinitionDetailsEle,
    "Additional Notes": additionalNotesDetailsEle,
    "Extra Definitions": extraDefinitionsDetailsEle,
    "Extra Info": extraInfoDetailsEle,
  }

  const logger = new JPMNLogger("open-on-new");
  let openOnNewEnabled = false;

  async function openOnNew() {
    if (openOnNewEnabled) {
      logger.debug("Open On New is already enabled");
      return;
    }
    openOnNewEnabled = true;

    const openFields = getSetting(['modules','open-on-new','open-fields',],['Extra Info']);
    let openFieldsEle = [];

    // doesn't do anything if the element doesn't exist in the first place
    //if (extraInfoDetailsEle === null) {
    //  return;
    //}
    for (f of openFields) {
      if (f in strToEle && strToEle[f] !== null) {
        openFieldsEle.push([f, strToEle[f]]);
      } else {
        logger.debug(`${f} field not found.`);
      }
    }

    if (openFieldsEle.length === 0) {
      logger.debug(`openFieldsEle contains 0 elements. Nothing to do.`);
      return;
    }

    // cancels if not new
    // refreshes on every new check, b/c one cannot assume that a card
    // is no longer new once you see a new card
    // (editing a new card will consistently refresh the currently new card)
    const key = "{{Key}}";
    if (key in isNewCardCache && !isNewCardCache[key]) {
      logger.debug("Key in new card cache and is not new.");
      return;
    }

    // requires that any of PAGraphs and UtilityDictionaries be filled to even open extra info
    if (!'{{#PAGraphs}}FILLED{{/PAGraphs}}{{#UtilityDictionaries}}FILLED{{/UtilityDictionaries}}') {
      logger.debug("Neither PAGraphs nor UtilityDictionaries exists");
      return;
    }

    logger.debug("Testing for new card...");

    function constructFindCardAction(query) {
      return {
        "action": "findCards",
        "params": {
          "query": query,
        }
      }
    }

    // constructs the multi findCards request for ankiconnect
    let actions = [];
    const cardTypeName = 'Mining Card';
    actions.push(constructFindCardAction(`"Key:${key}" "card:${cardTypeName}"`));
    actions.push(constructFindCardAction(`is:new "Key:${key}" "card:${cardTypeName}"`));

    const multi = await invoke("multi", {"actions": actions});
    const cards = multi[0];

    if (cards.length > 1) {
      logger.warn("Duplicate key found.");
      return;
    }
    if (cards.length == 0) {
      logger.error("Cannot find its own card?");
      return;
    }

    const isNew = (multi[1].length > 0);
    isNewCardCache[key] = isNew;

    if (isNew) {
      logger.debug("Card is new, opening fields...");
      for ([f, ele] of openFieldsEle) {
        logger.debug(`Opening ${f} field...`);
        toggleDetailsTag(ele);
      }
    } else {
      logger.debug("Card is not new.");
    }
  }



  class JPMNOpenOnNew {
    constructor() { }

    async run() {
      openOnNew();
    }
  }


  return JPMNOpenOnNew;

})();

/// 



// a general function to implement all keybinds necessary by the card.
// NOTICE: we MUST use document.onkeyup instead of document.addEventListener(...)
// because functions persist and cannot be easily removed within anki,
// whereas .onkeyup = ... replaces the previous function with the current.
document.onkeyup = (e => {
  let keys = null;
  let ele = null;

  // START_BLOCK: js_keybind_settings




  keys = getSetting(['keybinds','toggle-hybrid-sentence',],['n']);
  if (keys !== null && keys.includes(e.key)) {
    let hSent = document.getElementById("hybrid-sentence");
    let hWord = document.getElementById("hybrid-word");
    if (hSent !== null && hWord !== null) {
      hybridClick();
    }
  }

  keys = getSetting(['keybinds','toggle-highlight-word',],['n']);
  if (keys !== null && keys.includes(e.key)) {
    let paButton = document.getElementById("pa-button");
    if (paButton !== null) {
      toggleHighlightWord();
    }
  }

  /// 
  /// 
  // END_BLOCK: js_keybind_settings




  if (e.getModifierState && e.getModifierState('CapsLock')) {
    if (e.key === "CapsLock") {
      // either just enabled or disabled, not sure which one is which
      // it seems like normal browsers can't reach this point during (caps lock enabled -> caps lock disabled...)
      LOGGER.removeWarn("caps");
    } else if (!["Meta"].includes(e.key)) {
      LOGGER.debug(e.key);
      LOGGER.warn("Caps lock is enabled. Keybinds may not work as expected.", true, "caps")
    }
  } else {
    LOGGER.removeWarn("caps");
  }


  /// {{#WordAudio}}
  keys = getSetting(['keybinds','play-word-audio',],['w']);

  if (keys !== null && keys.includes(e.key)) {
    ele = document.querySelector("#word-audio .soundLink, #word-audio .replaybutton");
    if (ele) {
      ele.click();
    }
  }
  /// {{/WordAudio}}

  /// {{#SentenceAudio}}
  keys = getSetting(['keybinds','play-sentence-audio',],['p']);
  if (keys !== null && keys.includes(e.key)) {

    let hSent = document.getElementById("hybrid-sentence");

    /// 
      ele = document.querySelector("#sentence-audio .soundLink, #sentence-audio .replaybutton");
      if (ele) {
        ele.click();
      }
    /// 
  }
  /// {{/SentenceAudio}}

  keys = getSetting(['keybinds','toggle-front-full-sentence-display',],["'"]);
  ele = document.getElementById("full_sentence_front_details");
  if (keys !== null && ele && keys.includes(e.key)) {
    toggleDetailsTag(ele)
  }

  /// {{#Hint}}
  keys = getSetting(['keybinds','toggle-hint-display',],['.']);
  ele = document.getElementById("hint_details");
  if (keys !== null && ele && keys.includes(e.key)) {
    toggleDetailsTag(ele)
  }
  /// {{/Hint}}

  /// 
  /// {{#SecondaryDefinition}}
  keys = getSetting(['keybinds','toggle-secondary-definitions-display',],['8']);
  ele = document.getElementById("secondary_definition_details");
  if (keys !== null && ele && keys.includes(e.key)) {
    toggleDetailsTag(ele)
  }
  /// {{/SecondaryDefinition}}

  /// {{#AdditionalNotes}}
  keys = getSetting(['keybinds','toggle-additional-notes-display',],['9']);
  ele = document.getElementById("additional_notes_details");
  if (keys !== null && ele && keys.includes(e.key)) {
    toggleDetailsTag(ele)
  }
  /// {{/AdditionalNotes}}

  /// {{#ExtraDefinitions}}
  keys = getSetting(['keybinds','toggle-extra-definitions-display',],['0']);
  ele = document.getElementById("extra_definitions_details");
  if (keys !== null && ele && keys.includes(e.key)) {
    toggleDetailsTag(ele)
  }
  /// {{/ExtraDefinitions}}

  if ('{{#PAGraphs}}FILLED{{/PAGraphs}}{{#UtilityDictionaries}}FILLED{{/UtilityDictionaries}}') {
    keys = getSetting(['keybinds','toggle-extra-info-display',],['[']);
    ele = document.getElementById("extra_info_details");
    if (keys !== null && ele && keys.includes(e.key)) {
      toggleDetailsTag(ele)
    }
  }
  ///  

})


function main() {

  // sanity check
  if (typeof JPMNOpts === 'undefined') {
    LOGGER.warn("JPMNOpts was not defined in the options file. Was there an error?");
  }

  // START_BLOCK: js_run




  // checks leech
  const tagsEle = document.getElementById("tags");
  const tags = tagsEle.innerHTML.split(" ");
  if (tags.includes("leech")) {
    LOGGER.leech();
  }


  // checks that both `IsHoverCard` and `IsClickCard` are both not activated
  /// {{#IsHoverCard}}
  /// {{#IsClickCard}}
  LOGGER.warn("Both `IsHoverCard` and `IsClickCard` are filled. At most one should be filled at once.");
  /// {{/IsClickCard}}
  /// {{/IsHoverCard}}


  /// {{^SentenceReading}}
  if (getSetting(['no-sentence-reading-warn',],false)) {
    LOGGER.warn("`SentenceReading` is not filled out. Using `Sentence` field instead.");
  }
  /// {{/SentenceReading}}


  // removes greyed out fields if they should be hidden
  if ( !getSetting(['greyed-out-collapsable-fields-when-empty',],false)) {
    const elems = document.getElementsByClassName("glossary-details--grey");
    for (const x of elems) {
      x.style.display = "none";
    }
  }


  /// 


  // required for the sentence utils module
  var paIndicator;

  /// {{#PAShowInfo}}
  var paIndicator = (function () {
    let my = {};
    my.type = null;
    my.className = null;
    my.tooltip = null;

    if ('{{#PADoNotTest}}FILLED{{/PADoNotTest}}{{#PASeparateWordCard}}FILLED{{/PASeparateWordCard}}') {
      my.type = "none";
    } else if ('{{#PASeparateSentenceCard}}FILLED{{/PASeparateSentenceCard}}{{#PATestOnlyWord}}FILLED{{/PATestOnlyWord}}') {
      my.type = "word";
    } else if ('{{#IsSentenceCard}}FILLED{{/IsSentenceCard}}') {
      my.type = "sentence";
    } else {
      my.type = "word";
    }

    my.className = "pa-indicator-color--" + my.type;

    if (my.type === "none") {
      my.tooltip = "Do not test"
    } else if (my.type == "word") {
      my.tooltip = "Word"
    } else { // sentence
      my.tooltip = "Sentence"
    }

    return my;
  }());
  /// {{/PAShowInfo}}

  {

    let d = document.getElementById("display");
    let circ = document.getElementById("svg_circle");
    let svgTitle = document.getElementById("svg_title");

    /// {{#IsClickCard}}
    d.onclick = hybridClick;
    /// {{/IsClickCard}}


    // different circle positions depending on whether it's a sentence or not.
    // More specifically, checks if the first character is "「",
    // and adjusts the position based on that

    /// {{#PAShowInfo}}
    // ============================
    //  Word pitch indicator color
    // ============================
    // done in javascript to simplify templating logic
    if (svgTitle !== null) {
      svgTitle.textContent = "PA: " + paIndicator.tooltip;
    }

    circ.classList.add(paIndicator.className);
    /// {{/PAShowInfo}}
  }
  /// 

  // make sure the sentence is already 'clicked'
  /// {{#IsClickCard}}
  hybridClick()
  /// {{/IsClickCard}}

  /// 
  // END_BLOCK: js_run


  try { // RUN: sent-utils
    if (getSetting(['modules','sent-utils','enabled',],true)) {

      let isAltDisplay = !!'{{#AltDisplay}}FILLED{{/AltDisplay}}';
      let sent_utils = new JPMNSentUtils(isAltDisplay, false, paIndicator);
      sent_utils.run();

    }
    /// 
  } catch (error) {
    LOGGER.error("Error in module sent-utils:");
    LOGGER.errorStack(error.stack);
  }


  try { // RUN: kanji-hover

    // only continues if kanji-hover is actually enabled
    if (getSetting(['modules','kanji-hover','enabled',],true)) {
      const kanji_hover = new JPMNKanjiHover()
      if (getSetting(['modules','kanji-hover','mode',],1) === 0) {
        kanji_hover.run();
      } else { // === 1
        const wordReading = document.getElementById("dh_reading");
        wordReading.onmouseover = function() {
          // replaces the function with a null function to avoid calling this function
          wordReading.onmouseover = function() {}
          kanji_hover.run();
        }
      }
    }

    /// 
  } catch (error) {
    LOGGER.error("Error in module kanji-hover:");
    LOGGER.errorStack(error.stack);
  }


  try { // RUN: auto-pitch-accent

    if (getSetting(['modules','auto-pitch-accent','enabled',],true)) {
      const auto_pa = new JPMNAutoPA();
      auto_pa.run();
    }

    /// 
  } catch (error) {
    LOGGER.error("Error in module auto-pitch-accent:");
    LOGGER.errorStack(error.stack);
  }


  try { // RUN: img-utils

    if (getSetting(['modules','img-utils','enabled',],true)) {
      const img_utils = new JPMNImgUtils();
      img_utils.run();
    }

    /// 
  } catch (error) {
    LOGGER.error("Error in module img-utils:");
    LOGGER.errorStack(error.stack);
  }


  try { // RUN: open_on_new

    if (getSetting(['modules','open-on-new','enabled',],false)) {
      const open_on_new = new JPMNOpenOnNew()
      open_on_new.run();
    }

    /// 
  } catch (error) {
    LOGGER.error("Error in module open_on_new:");
    LOGGER.errorStack(error.stack);
  }

}



main();



}());

</script>




